{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deadlock missions Overview This documentation is mainly used to help everyone with the creation of their own learning content, through Deadlock platform. What is a mission ? A mission is mainly these elements: A documentation: instructions for the user A template folder: code provided to the user A success folder: solution of the challenge An app folder: logic to verify user code The mission descriptor: challenge.yml Many hints: You can add different hints, each one could be unlock with token, user unlock You can discover many elements on the user interface: Documentation with briefing (main informations), hints Provided code Run button is used to execute code without any test Submit button is used to execute test on user code Getting Started Each mission came with a special structure, it will be provided by our DCLI tool So it's pretty easy to start any challenge, you will just have to care what you want to deliver to your users. Install DCLI Requirements: Docker ( as non-root user ) Python >= 3.2 pip installed ( with python or from your package manager) Install dcli package using pip: pip3 install deadlock-cli Then you shoud have dcli command on your system. Run dcli --help to check that everything worked well. If you have something like command not found or module not found when you run dcli try to export /home/user/.local/bin/ to your $PATH. > dcli --help # man page should be printed > dcli version current is 1 .2.0 Create your first code challenge Let's create a Java mission to explain you the concept behind the structure. Java is just for the example, once you understand the architecture you will be able to create a challenge in any language. Furthermore dcli is able to generate other languages, we also have different examples . Let's start with a Java example: > dcli gen java We will generate a simple mission where the user must return Hello World! . You can explore the generated code_hello_world directory: code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Run.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png As you saw it, the goal is simple, implement the sayHello() method within template package. All files under template package will be served to the user, you can create as much as you want. The HelloWorld.java file under success package will be served only when the user succeed the challenge. You have to complete all //TODO present in the code. Let's start with src/main/java/success/HelloWorld.java , this is the solution file. public static String sayHello () { //TODO write your own solution return null ; } Pretty simple the method has to return \"Hello World!\" . Next part is to compare the user result with the expected result, this part is done under src/main/java/app/Solve.java . Dcli generates some part of code for you but have to complete with your own logic. public static void main ( String [] args ) { try { // user result String userResult = HelloWorld . sayHello (); // your solution result String expectedResult = success . HelloWorld . sayHello (); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if ( expectedResult . equals ( userResult )) { // if all test passed successfully Logger . logSuccess (); } else { Logger . logFail ( expectedResult , userResult ); System . exit ( 1 ); } } catch ( RuntimeException e ) { Logger . logException ( e ); // if something bad happened exit with error code System . exit ( 1 ); } } What it does is that if the function HelloWorld.sayHello() does not return \"Hello World!\" or throws an exception, it logs an error and exits with an error code. In general, there are 2 kinds of outputs you have to take into account. Error: The code sent does not compile, does not have the right signature, code did not return the expected result, something bad happened. Success: The code did complete normally and returned the expected result A simple Logger class is also generated. You can now test your mission with the following command lines: > cd ./code_hello_world > dcli run . # Run the program, execute the file `src/main/java/app/Run.java` > dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` You can try to modify the HelloWorld.java file under template package to reach the solution like you were the candidate. Documentation The documentation is stored in code_hello_world/docs/ . It contains the Briefing to expose the problem your candidate has to solve and motivate him. It should be written in Markdown, it supports HTML tags and LateX language. briefing.md: contains the default instructions debriefing.md: contains a text provided when user solve the challenge hint1.md: first hint user can unlock (optional) hint2.md: an other hint (optional) examples of hints: hint1.md The String that you need to return is the two words that you usually display when you start learning a language for instance. It can be considered as a greeting. (PS: the word is not \"It Works\") hint2.md Alright, the String is case sensitive, so you might want to try multiple cases. Also, we were very emotional when we wrote this challenge, and decided to end the phrase with a \"!\" N.B.: hint2 will always be given after hint1. At this point, we have a functional Java application that will test the content of a compiled HelloWorld.class class and exit the relevant code. If you want to understand more how the mission works and custom more your mission you can read this . i18n The default files into the docs folder contains the english translations. If you want handle other languages you have to create new directories following this way: docs briefing.md fr briefing.md and so on. Level Each mission has his own level Jajarbinks (easiest) Ewok Padawan Jedi Master (hardest) When you create your own mission your can help you with the references to set a correct level to your challenge. What's next You can explore different types of challenge: VsCode Multi language Multi Service Score SQL","title":"Home"},{"location":"#deadlock-missions","text":"","title":"Deadlock missions"},{"location":"#overview","text":"This documentation is mainly used to help everyone with the creation of their own learning content, through Deadlock platform.","title":"Overview"},{"location":"#what-is-a-mission","text":"A mission is mainly these elements: A documentation: instructions for the user A template folder: code provided to the user A success folder: solution of the challenge An app folder: logic to verify user code The mission descriptor: challenge.yml Many hints: You can add different hints, each one could be unlock with token, user unlock You can discover many elements on the user interface: Documentation with briefing (main informations), hints Provided code Run button is used to execute code without any test Submit button is used to execute test on user code","title":"What is a mission ?"},{"location":"#getting-started","text":"Each mission came with a special structure, it will be provided by our DCLI tool So it's pretty easy to start any challenge, you will just have to care what you want to deliver to your users.","title":"Getting Started"},{"location":"#install-dcli","text":"Requirements: Docker ( as non-root user ) Python >= 3.2 pip installed ( with python or from your package manager) Install dcli package using pip: pip3 install deadlock-cli Then you shoud have dcli command on your system. Run dcli --help to check that everything worked well. If you have something like command not found or module not found when you run dcli try to export /home/user/.local/bin/ to your $PATH. > dcli --help # man page should be printed > dcli version current is 1 .2.0","title":"Install DCLI"},{"location":"#create-your-first-code-challenge","text":"Let's create a Java mission to explain you the concept behind the structure. Java is just for the example, once you understand the architecture you will be able to create a challenge in any language. Furthermore dcli is able to generate other languages, we also have different examples . Let's start with a Java example: > dcli gen java We will generate a simple mission where the user must return Hello World! . You can explore the generated code_hello_world directory: code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Run.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png As you saw it, the goal is simple, implement the sayHello() method within template package. All files under template package will be served to the user, you can create as much as you want. The HelloWorld.java file under success package will be served only when the user succeed the challenge. You have to complete all //TODO present in the code. Let's start with src/main/java/success/HelloWorld.java , this is the solution file. public static String sayHello () { //TODO write your own solution return null ; } Pretty simple the method has to return \"Hello World!\" . Next part is to compare the user result with the expected result, this part is done under src/main/java/app/Solve.java . Dcli generates some part of code for you but have to complete with your own logic. public static void main ( String [] args ) { try { // user result String userResult = HelloWorld . sayHello (); // your solution result String expectedResult = success . HelloWorld . sayHello (); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if ( expectedResult . equals ( userResult )) { // if all test passed successfully Logger . logSuccess (); } else { Logger . logFail ( expectedResult , userResult ); System . exit ( 1 ); } } catch ( RuntimeException e ) { Logger . logException ( e ); // if something bad happened exit with error code System . exit ( 1 ); } } What it does is that if the function HelloWorld.sayHello() does not return \"Hello World!\" or throws an exception, it logs an error and exits with an error code. In general, there are 2 kinds of outputs you have to take into account. Error: The code sent does not compile, does not have the right signature, code did not return the expected result, something bad happened. Success: The code did complete normally and returned the expected result A simple Logger class is also generated. You can now test your mission with the following command lines: > cd ./code_hello_world > dcli run . # Run the program, execute the file `src/main/java/app/Run.java` > dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` You can try to modify the HelloWorld.java file under template package to reach the solution like you were the candidate.","title":"Create your first code challenge"},{"location":"#documentation","text":"The documentation is stored in code_hello_world/docs/ . It contains the Briefing to expose the problem your candidate has to solve and motivate him. It should be written in Markdown, it supports HTML tags and LateX language. briefing.md: contains the default instructions debriefing.md: contains a text provided when user solve the challenge hint1.md: first hint user can unlock (optional) hint2.md: an other hint (optional) examples of hints: hint1.md The String that you need to return is the two words that you usually display when you start learning a language for instance. It can be considered as a greeting. (PS: the word is not \"It Works\") hint2.md Alright, the String is case sensitive, so you might want to try multiple cases. Also, we were very emotional when we wrote this challenge, and decided to end the phrase with a \"!\" N.B.: hint2 will always be given after hint1. At this point, we have a functional Java application that will test the content of a compiled HelloWorld.class class and exit the relevant code. If you want to understand more how the mission works and custom more your mission you can read this .","title":"Documentation"},{"location":"#i18n","text":"The default files into the docs folder contains the english translations. If you want handle other languages you have to create new directories following this way: docs briefing.md fr briefing.md and so on.","title":"i18n"},{"location":"#level","text":"Each mission has his own level Jajarbinks (easiest) Ewok Padawan Jedi Master (hardest) When you create your own mission your can help you with the references to set a correct level to your challenge.","title":"Level"},{"location":"#whats-next","text":"You can explore different types of challenge: VsCode Multi language Multi Service Score SQL","title":"What's next"},{"location":"contributing/","text":"Contributing to Deadlock missions An introduction to contributing to the Deadlock project. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews Our projects you can contribute: Challenge examples Challenge documentation Dcli","title":"Contributing"},{"location":"contributing/#contributing-to-deadlock-missions","text":"An introduction to contributing to the Deadlock project. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews Our projects you can contribute: Challenge examples Challenge documentation Dcli","title":"Contributing to Deadlock missions"},{"location":"help/","text":"To get help with Deadlock Challenge, please use the GitHub mission example issues or GitHub mission documentation issues .","title":"Getting help"},{"location":"how-does-it-work/","text":"How does it work ? If you are here, you already read the Getting Started and you want to explore more about how a mission works. We are going to explain you different files, To be sure to understand the next parts you have to be familiar with: Docker Yaml file Dockerfile When your candidate submits his code, a Docker container will be created. The name of the Docker image will be your mission name, prefixed with code_ . Important: your container should have its own CMD or ENTRYPOINT defined. Before your container is executed, your candidate code will be pasted within template folder. Where and what this file is entirely up to you and shall be submitted in the descriptor . Once the code is inside the container, your container will be ran until completion. Note that the STDOUT and STDERR signals will be streamed to the candidate. Once it completes, the exit code will be checked. If the exit code is 0 , the mission was completed successfully. Otherwise , it means the candidate has failed . You can custom the Dockerfile has you wish, include external library to allow your user to have new experiences ! Example of a python mission with nymphy, sklearn and pandas libraries : FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [ \"/run.sh\" ] The build step is done only one time when your mission is accepeted by the Deadlock team. Mission descriptor Each mission has its own mission descriptor in challengename/challenge.yaml. It is used to create the mission container and retrieve your specifications regarding the language and file target. version: 1 .0 # You have to increase it if you have changed something in your code name: code_halloween_candy # your mission name. MUST be equal to the mission folder label: Halloween Candy # your mission label description: Help your brother split his halloween candy # your mission description, in english level: jarjarbinks # your mission level. From easiest to hardest: jarjarbinks, ewok, padawan, jedi, master type: CODING # this is a coding game meta: private: true # if true mission will only be visible on your instance (youSchool.deadlock.io), default to false, visible by everyone. xp: # the experience it should bring. any label is supported programming: 1 # this is a weight, not a number java: 1 coding: # coding game specifics templateDirectory: src/java/main/template # code provided to the user successDirectory: src/java/main/success # solution of the challenge target: CandySplitter.java # the target file path, consider as Main file editorMode: java # the language to be displayed by the web editor","title":"How does it work ?"},{"location":"how-does-it-work/#how-does-it-work","text":"If you are here, you already read the Getting Started and you want to explore more about how a mission works. We are going to explain you different files, To be sure to understand the next parts you have to be familiar with: Docker Yaml file","title":"How does it work ?"},{"location":"how-does-it-work/#dockerfile","text":"When your candidate submits his code, a Docker container will be created. The name of the Docker image will be your mission name, prefixed with code_ . Important: your container should have its own CMD or ENTRYPOINT defined. Before your container is executed, your candidate code will be pasted within template folder. Where and what this file is entirely up to you and shall be submitted in the descriptor . Once the code is inside the container, your container will be ran until completion. Note that the STDOUT and STDERR signals will be streamed to the candidate. Once it completes, the exit code will be checked. If the exit code is 0 , the mission was completed successfully. Otherwise , it means the candidate has failed . You can custom the Dockerfile has you wish, include external library to allow your user to have new experiences ! Example of a python mission with nymphy, sklearn and pandas libraries : FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [ \"/run.sh\" ] The build step is done only one time when your mission is accepeted by the Deadlock team.","title":"Dockerfile"},{"location":"how-does-it-work/#mission-descriptor","text":"Each mission has its own mission descriptor in challengename/challenge.yaml. It is used to create the mission container and retrieve your specifications regarding the language and file target. version: 1 .0 # You have to increase it if you have changed something in your code name: code_halloween_candy # your mission name. MUST be equal to the mission folder label: Halloween Candy # your mission label description: Help your brother split his halloween candy # your mission description, in english level: jarjarbinks # your mission level. From easiest to hardest: jarjarbinks, ewok, padawan, jedi, master type: CODING # this is a coding game meta: private: true # if true mission will only be visible on your instance (youSchool.deadlock.io), default to false, visible by everyone. xp: # the experience it should bring. any label is supported programming: 1 # this is a weight, not a number java: 1 coding: # coding game specifics templateDirectory: src/java/main/template # code provided to the user successDirectory: src/java/main/success # solution of the challenge target: CandySplitter.java # the target file path, consider as Main file editorMode: java # the language to be displayed by the web editor","title":"Mission descriptor"},{"location":"reference/","text":"Reference level mission list Hence you have some example of already existing missions. Each one has been set into a level, you can use them to classify your mission among the five levels. Jajarbinks Ewok Padawan Jedi Master Let's dance Collision box in da box Game of Life Collision circle vs segment Mario Needs Help Romanizer Fibo challenge Midnight Club Basics 2 Military Satellite Caesar Decipher The Secret Message Recommendation Netflix Out of pub","title":"Reference level mission list"},{"location":"reference/#reference-level-mission-list","text":"Hence you have some example of already existing missions. Each one has been set into a level, you can use them to classify your mission among the five levels. Jajarbinks Ewok Padawan Jedi Master Let's dance Collision box in da box Game of Life Collision circle vs segment Mario Needs Help Romanizer Fibo challenge Midnight Club Basics 2 Military Satellite Caesar Decipher The Secret Message Recommendation Netflix Out of pub","title":"Reference level mission list"},{"location":"submit/","text":"As a professor you can submit your challenge at https://takima.deadlock.io/missions/upload If you have any suggestions, or need help","title":"Submit"},{"location":"challenge-types/code/","text":"Code examples Here are some examples for different languages: C example Cpp example Java example Java Maven example Ocaml example Python example Score Python example SQL example","title":"Examples"},{"location":"challenge-types/code/#code-examples","text":"Here are some examples for different languages: C example Cpp example Java example Java Maven example Ocaml example Python example Score Python example SQL example","title":"Code examples"},{"location":"challenge-types/java_maven/","text":"Java Maven When creating a Java Maven mission, you need to download all the project's dependencies in a build.sh with Maven. #!/bin/sh # Script runned before building Docker image # Download all dependencies of the project to put them into the Docker image via Dockerfile # Here we have defined our dependencies into a jar directory mvn -B dependency:copy-dependencies -DoutputDirectory = jar Then the dependencies need to be put in a Dockerfile # Add all dependency jars ADD jar src/main/java/jar Challenge.yml file you have to complete the challenge.yaml file: version : 1.0 name : code_calculator label : Calculator challenge description : Implement calculator operations level : ewok type : CODING xp : java : 1 programming : 1 coding : templateDirectory : src/main/java/template successDirectory : src/main/java/success target : Calculator.java editorMode : java Template and Success directories The 'template/' directory contains the code that will be written by the user trying to solve the challenge. The success/ directory contains your solution given to the user when it succeeded the challenge. You can provide the implementation you wish. To test your program you can use our CLI : > dcli run . # Will run template/ > dcli solve . # Will execute tests on template/ Tree example of Java Maven challenge \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 jar \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Run.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2514\u2500\u2500 success \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java Example code_java_maven","title":"Java Maven"},{"location":"challenge-types/java_maven/#java-maven","text":"When creating a Java Maven mission, you need to download all the project's dependencies in a build.sh with Maven. #!/bin/sh # Script runned before building Docker image # Download all dependencies of the project to put them into the Docker image via Dockerfile # Here we have defined our dependencies into a jar directory mvn -B dependency:copy-dependencies -DoutputDirectory = jar Then the dependencies need to be put in a Dockerfile # Add all dependency jars ADD jar src/main/java/jar","title":"Java Maven"},{"location":"challenge-types/java_maven/#challengeyml-file","text":"you have to complete the challenge.yaml file: version : 1.0 name : code_calculator label : Calculator challenge description : Implement calculator operations level : ewok type : CODING xp : java : 1 programming : 1 coding : templateDirectory : src/main/java/template successDirectory : src/main/java/success target : Calculator.java editorMode : java","title":"Challenge.yml file"},{"location":"challenge-types/java_maven/#template-and-success-directories","text":"The 'template/' directory contains the code that will be written by the user trying to solve the challenge. The success/ directory contains your solution given to the user when it succeeded the challenge. You can provide the implementation you wish. To test your program you can use our CLI : > dcli run . # Will run template/ > dcli solve . # Will execute tests on template/","title":"Template and Success directories"},{"location":"challenge-types/java_maven/#tree-example-of-java-maven-challenge","text":"\u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 jar \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Run.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2514\u2500\u2500 success \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java","title":"Tree example of Java Maven challenge"},{"location":"challenge-types/java_maven/#example","text":"code_java_maven","title":"Example"},{"location":"challenge-types/metamorph/","text":"Multi language When you are creating a challenge, you can create one independent of the programming language. It gives the ability for the final user to select it's own programming language! Available languages : Java 11.0.5 (openjdk) Kotlin 1.3.70-eap-184 Python 3.8.2 C/C++ 9.2.0 Rust 1.39.0 Go 1.12.16 Javascript with NodeJS 12.15.0 Ruby 2.6.6 Ocaml 4.08.1 Let's say you want write a Fibonacci challenge. Create a new directory and create a entry.rs file, it will define: - which language is available for the user, - all your tests to validate user code. 1 2 3 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ] }} In the first array you are listing all languages the user will be able to chose on the page. Then you are going to write different tests, which one will be run if the previous one succeeded. Let's write the first one ! 1 2 3 4 5 6 7 8 9 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 } ] }} It will call the user program with the 0 as input and is waiting to have 1 as ouput. By default for each language the user will have a template, you can custom each one for each language: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { if ( args . length > 0 ) { // Called when you submit your code. System . out . println ( fibonacci ( Long . ValueOf ( args [ 0 ] ))); } else { // Called when you run your code. System . out . println ( \"Hello World!\" ); } } public static long fibonacci ( long n ) { return n ; } } Javascript 1 2 3 4 5 6 7 8 9 10 11 12 // CommonJS if ( process . argv . length > 2 ) { // args given, code submitted console . log ( fibonacci ( process . argv [ 2 ])); } else { // no given, code ran console . log ( \"Hello World!\" ); } function fibonacci ( n ) { return n ; } Python 1 2 3 4 5 6 7 8 9 10 11 import sys ; def fibonacci ( n ): return n if ( len ( sys . argv ) > 1 ): # args given, code submitted print ( fibonacci ( sys . argv [ 1 ])) else : # no given, code ran print ( \"Hello World!\" ) Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"os\" ) func Fibonacci ( n int64 ) int64 { return n } func main () { if ( len ( os . Args ) > 1 ) { // args given, code submitted arg := os . Args [ 1 ] fmt . Println ( Fibonacci ( arg )) } else { // no given, code ran fmt . Println ( \"Hello World!\" ) } } C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <stdlib.h> long fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( argv [ 1 ])); } else { // no given, code ran printf ( \"Hello World!\" ); } } Cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <bits/stdc++.h> bool fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( stol ( argv [ 1 ]))) } else { // no given, code ran printf ( \"Hello World!\" ); } } Ocaml 1 2 3 4 5 6 7 8 9 10 let fibonacci n = let rec fib_2termes n a b = match n with | 0 -> a | 1 -> b | _ -> fib_2termes ( n - 1 ) b ( a + b ) in fib_2termes n 0 1 ;; if Array . length Sys . argv > 1 = true then print_int ( fibonacci ( int_of_string Sys . argv .( 1 )));; Rust 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); if args . len () == 2 { // Called when you submit your code. println! ( \"{}\" , fibonacci ( & args [ 1 ])) } else { // Called when you run your code. println! ( \"Hello World!\" ) } } fn fibonacci ( n : i64 ) -> i64 { n } Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main def initialize if ( ARGV . length () > 0 ) then puts fibonacci ( ARGV [ 0 ]. to_i ) # args given, code submitted else puts \"Hello World!\" # no args given, code runner end end def fibonacci ( n ) 0 end end # initialize object Main . new The user will have to fill the fibonacci method and the result will be printed into the stdout. Keep going with more tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 }, { input : 1 , expected : 1 }, { input : 2 , expected : 2 }, { input : 3 , expected : 3 }, { input : 10 , expected : 89 } ] }} Sounds a bit static ? You can add more complex tests using random method available by our runner: randt(n) : random from 0 included to n excluded. randft(n, m) : random from n included to m excluded. { input : randft ( 20 , 30 ), expected : ? } Which give us a problem, what to write for the expected value ? No worries! You can call your own solution instead of writing something static! { input : randft ( 20 , 30 ), expected : call ( \"java\" , \"Solution.java\" ) }, { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ) } It will be the same logic, your solution.py will be called by our Python interpreter with the input value and you have to write the solution result to the stdout . For instance with Fibonacci: # solution.py def fibo ( n ): if n <= 1 : return n else : return ( fibo ( n - 1 ) + fibo ( n - 2 )) print ( fibo ( sys . argv [ 1 ])) Then the stdout given with print will be compared with the user program. You can choose amoung these interpreters: java javascript ruby c rust python go cpp Repeat But what if you wish to execute 50 times a random test? That's not a problem, add the repeat parameter to your test: { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ), repeat : 50 } Input call That's not all, you can also call your own program to generate the input: { input : call ( \"javascript\" , \"generate.js\" ), expected : call ( \"python\" , \"solution.py\" ) } Open a file You can also open a file: { input : open ( \"file.txt\" ), expected : call ( \"python\" , \"solution.py\" ) } It will be given as a String to the user. Once you have complete the entry.rs you have to complete the challenge.yaml file: version : 1.0 name : code_metamorph_fibo label : Fibonacci description : Implements Fibonacci algorithm level : ewok type : CODING metamorph : true xp : programming : 1 coding : templateDirectory : /opt/runner successDirectory : success/ target : main.rs editorMode : rust The success/ directory contains your solution given to the user when it succeeded the challenge. You can provide the implementation you wish. To test your program you can use our CLI : > dcli run . java # Will run template/java/Main.java > dcli solve . java # Will execute tests on template/java/Main.java > dcli run . python # Will run template/python/Main.py Each file placed within a template is provided if the user decide to change the current language. For instance if the user decide to use Rust interpreter, all files under template/rust will be provided. What's your challenge must like: . \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 entry.rs \u251c\u2500\u2500 runner \u251c\u2500\u2500 solution.js \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 Main.rs \u2514\u2500\u2500 template \u251c\u2500\u2500 c \u2502 \u2514\u2500\u2500 Main.c \u251c\u2500\u2500 cpp \u2502 \u2514\u2500\u2500 Main.cpp \u251c\u2500\u2500 go \u2502 \u2514\u2500\u2500 Main.go \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 Main.java \u251c\u2500\u2500 javascript \u2502 \u2514\u2500\u2500 Main.js \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 Main.py \u251c\u2500\u2500 ruby \u2502 \u2514\u2500\u2500 Main.rb \u2514\u2500\u2500 rust \u2514\u2500\u2500 Main.rs","title":"Multi language"},{"location":"challenge-types/metamorph/#multi-language","text":"When you are creating a challenge, you can create one independent of the programming language. It gives the ability for the final user to select it's own programming language! Available languages : Java 11.0.5 (openjdk) Kotlin 1.3.70-eap-184 Python 3.8.2 C/C++ 9.2.0 Rust 1.39.0 Go 1.12.16 Javascript with NodeJS 12.15.0 Ruby 2.6.6 Ocaml 4.08.1 Let's say you want write a Fibonacci challenge. Create a new directory and create a entry.rs file, it will define: - which language is available for the user, - all your tests to validate user code. 1 2 3 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ] }} In the first array you are listing all languages the user will be able to chose on the page. Then you are going to write different tests, which one will be run if the previous one succeeded. Let's write the first one ! 1 2 3 4 5 6 7 8 9 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 } ] }} It will call the user program with the 0 as input and is waiting to have 1 as ouput. By default for each language the user will have a template, you can custom each one for each language: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { if ( args . length > 0 ) { // Called when you submit your code. System . out . println ( fibonacci ( Long . ValueOf ( args [ 0 ] ))); } else { // Called when you run your code. System . out . println ( \"Hello World!\" ); } } public static long fibonacci ( long n ) { return n ; } } Javascript 1 2 3 4 5 6 7 8 9 10 11 12 // CommonJS if ( process . argv . length > 2 ) { // args given, code submitted console . log ( fibonacci ( process . argv [ 2 ])); } else { // no given, code ran console . log ( \"Hello World!\" ); } function fibonacci ( n ) { return n ; } Python 1 2 3 4 5 6 7 8 9 10 11 import sys ; def fibonacci ( n ): return n if ( len ( sys . argv ) > 1 ): # args given, code submitted print ( fibonacci ( sys . argv [ 1 ])) else : # no given, code ran print ( \"Hello World!\" ) Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"os\" ) func Fibonacci ( n int64 ) int64 { return n } func main () { if ( len ( os . Args ) > 1 ) { // args given, code submitted arg := os . Args [ 1 ] fmt . Println ( Fibonacci ( arg )) } else { // no given, code ran fmt . Println ( \"Hello World!\" ) } } C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <stdlib.h> long fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( argv [ 1 ])); } else { // no given, code ran printf ( \"Hello World!\" ); } } Cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <bits/stdc++.h> bool fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( stol ( argv [ 1 ]))) } else { // no given, code ran printf ( \"Hello World!\" ); } } Ocaml 1 2 3 4 5 6 7 8 9 10 let fibonacci n = let rec fib_2termes n a b = match n with | 0 -> a | 1 -> b | _ -> fib_2termes ( n - 1 ) b ( a + b ) in fib_2termes n 0 1 ;; if Array . length Sys . argv > 1 = true then print_int ( fibonacci ( int_of_string Sys . argv .( 1 )));; Rust 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); if args . len () == 2 { // Called when you submit your code. println! ( \"{}\" , fibonacci ( & args [ 1 ])) } else { // Called when you run your code. println! ( \"Hello World!\" ) } } fn fibonacci ( n : i64 ) -> i64 { n } Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main def initialize if ( ARGV . length () > 0 ) then puts fibonacci ( ARGV [ 0 ]. to_i ) # args given, code submitted else puts \"Hello World!\" # no args given, code runner end end def fibonacci ( n ) 0 end end # initialize object Main . new The user will have to fill the fibonacci method and the result will be printed into the stdout. Keep going with more tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 }, { input : 1 , expected : 1 }, { input : 2 , expected : 2 }, { input : 3 , expected : 3 }, { input : 10 , expected : 89 } ] }} Sounds a bit static ? You can add more complex tests using random method available by our runner: randt(n) : random from 0 included to n excluded. randft(n, m) : random from n included to m excluded. { input : randft ( 20 , 30 ), expected : ? } Which give us a problem, what to write for the expected value ? No worries! You can call your own solution instead of writing something static! { input : randft ( 20 , 30 ), expected : call ( \"java\" , \"Solution.java\" ) }, { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ) } It will be the same logic, your solution.py will be called by our Python interpreter with the input value and you have to write the solution result to the stdout . For instance with Fibonacci: # solution.py def fibo ( n ): if n <= 1 : return n else : return ( fibo ( n - 1 ) + fibo ( n - 2 )) print ( fibo ( sys . argv [ 1 ])) Then the stdout given with print will be compared with the user program. You can choose amoung these interpreters: java javascript ruby c rust python go cpp","title":"Multi language"},{"location":"challenge-types/metamorph/#repeat","text":"But what if you wish to execute 50 times a random test? That's not a problem, add the repeat parameter to your test: { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ), repeat : 50 }","title":"Repeat"},{"location":"challenge-types/metamorph/#input-call","text":"That's not all, you can also call your own program to generate the input: { input : call ( \"javascript\" , \"generate.js\" ), expected : call ( \"python\" , \"solution.py\" ) }","title":"Input call"},{"location":"challenge-types/metamorph/#open-a-file","text":"You can also open a file: { input : open ( \"file.txt\" ), expected : call ( \"python\" , \"solution.py\" ) } It will be given as a String to the user. Once you have complete the entry.rs you have to complete the challenge.yaml file: version : 1.0 name : code_metamorph_fibo label : Fibonacci description : Implements Fibonacci algorithm level : ewok type : CODING metamorph : true xp : programming : 1 coding : templateDirectory : /opt/runner successDirectory : success/ target : main.rs editorMode : rust The success/ directory contains your solution given to the user when it succeeded the challenge. You can provide the implementation you wish. To test your program you can use our CLI : > dcli run . java # Will run template/java/Main.java > dcli solve . java # Will execute tests on template/java/Main.java > dcli run . python # Will run template/python/Main.py Each file placed within a template is provided if the user decide to change the current language. For instance if the user decide to use Rust interpreter, all files under template/rust will be provided. What's your challenge must like: . \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 entry.rs \u251c\u2500\u2500 runner \u251c\u2500\u2500 solution.js \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 Main.rs \u2514\u2500\u2500 template \u251c\u2500\u2500 c \u2502 \u2514\u2500\u2500 Main.c \u251c\u2500\u2500 cpp \u2502 \u2514\u2500\u2500 Main.cpp \u251c\u2500\u2500 go \u2502 \u2514\u2500\u2500 Main.go \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 Main.java \u251c\u2500\u2500 javascript \u2502 \u2514\u2500\u2500 Main.js \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 Main.py \u251c\u2500\u2500 ruby \u2502 \u2514\u2500\u2500 Main.rb \u2514\u2500\u2500 rust \u2514\u2500\u2500 Main.rs","title":"Open a file"},{"location":"challenge-types/multi-service/","text":"Multi-service missions Sometimes, you may have to declare multiple services in your challenge. This feature is fully supported and uses containers within one network. Here is a walkthrough of adding another service named db . In the main folder of your challenge, create the directories code_your_mission/services/db . This directory will contain your service files. In this folder, you must declare at least two files: The service descriptor service.yaml The service container Dockerfile The service descriptor The service descriptor can expose ports and a specific alias (which must be the service name). Following on our example, the db service would be: name : db exposed_ports : - 5432 You can find an example of a multi services mission though SQL type challenge .","title":"Multi service"},{"location":"challenge-types/multi-service/#multi-service-missions","text":"Sometimes, you may have to declare multiple services in your challenge. This feature is fully supported and uses containers within one network. Here is a walkthrough of adding another service named db . In the main folder of your challenge, create the directories code_your_mission/services/db . This directory will contain your service files. In this folder, you must declare at least two files: The service descriptor service.yaml The service container Dockerfile","title":"Multi-service missions"},{"location":"challenge-types/multi-service/#the-service-descriptor","text":"The service descriptor can expose ports and a specific alias (which must be the service name). Following on our example, the db service would be: name : db exposed_ports : - 5432 You can find an example of a multi services mission though SQL type challenge .","title":"The service descriptor"},{"location":"challenge-types/score/","text":"Score challenge When you are creating a code mission, the user has two ways to execute the code ( see more information on main page ): Run -> will only run the code without any test Submit -> will run the code with tests you have wrote. You are able to return a score when you test the user code. For instance if you consider 50 out of 100 tests succeeded you must write it that way (depends of the language): Java public static void main ( String [] args ) { // test user code Mission . INSTANCE . done ( 50 ); } Python def main (): # test user code Mission . done ( 50 ): You also have to specify within the challenge.yaml different fields: score : min : 0 # default min score, can be omitted minToValidate : 90 max : 100 # default max score, can be omitted At the end on the interface your users will get a new tab next to the Console . Example code_score_python","title":"Score"},{"location":"challenge-types/score/#score-challenge","text":"When you are creating a code mission, the user has two ways to execute the code ( see more information on main page ): Run -> will only run the code without any test Submit -> will run the code with tests you have wrote. You are able to return a score when you test the user code. For instance if you consider 50 out of 100 tests succeeded you must write it that way (depends of the language): Java public static void main ( String [] args ) { // test user code Mission . INSTANCE . done ( 50 ); } Python def main (): # test user code Mission . done ( 50 ): You also have to specify within the challenge.yaml different fields: score : min : 0 # default min score, can be omitted minToValidate : 90 max : 100 # default max score, can be omitted At the end on the interface your users will get a new tab next to the Console .","title":"Score challenge"},{"location":"challenge-types/score/#example","text":"code_score_python","title":"Example"},{"location":"challenge-types/sql/","text":"SQL missions A SQL mission is a code mission with a remote database as service, more information about service . The main container will connect to the service, execute the user queries on it, then will check everything went well. There is two main kinds of SQL missions: Read-only missions For example your answer is something like SELECT * FROM public.\"myTable\" ... In this case, you need to * Run the expected answer and store answer first ! * Run the given answer and store answer only after ! * Compare both answer You need to run your order first to avoid rollback the database in case of the user modifies it Read-write missions This kind of mission is a little bit more complicated to validate. They mainly start with DELETE/UPDATE/ALTER TABLE ... In this case, you need to write a checker.sql (usually with a SELECT request) file in addition to success/query.sql. The success/query.sql will modifies the database (like the expected answer) and the checker.sql will select all interesting rows in the database Run the expected answer Run the checker.sql script and store the answer Rollback the database Run the given answer Run the checker.sql script and store the answer Compare both answer Tree example of SQL challenge \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png Example https://github.com/deadlock-resources/challenge-examples/tree/master/example/code_sql","title":"SQL"},{"location":"challenge-types/sql/#sql-missions","text":"A SQL mission is a code mission with a remote database as service, more information about service . The main container will connect to the service, execute the user queries on it, then will check everything went well. There is two main kinds of SQL missions:","title":"SQL missions"},{"location":"challenge-types/sql/#read-only-missions","text":"For example your answer is something like SELECT * FROM public.\"myTable\" ... In this case, you need to * Run the expected answer and store answer first ! * Run the given answer and store answer only after ! * Compare both answer You need to run your order first to avoid rollback the database in case of the user modifies it","title":"Read-only missions"},{"location":"challenge-types/sql/#read-write-missions","text":"This kind of mission is a little bit more complicated to validate. They mainly start with DELETE/UPDATE/ALTER TABLE ... In this case, you need to write a checker.sql (usually with a SELECT request) file in addition to success/query.sql. The success/query.sql will modifies the database (like the expected answer) and the checker.sql will select all interesting rows in the database Run the expected answer Run the checker.sql script and store the answer Rollback the database Run the given answer Run the checker.sql script and store the answer Compare both answer","title":"Read-write missions"},{"location":"challenge-types/sql/#tree-example-of-sql-challenge","text":"\u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png","title":"Tree example of SQL challenge"},{"location":"challenge-types/sql/#example","text":"https://github.com/deadlock-resources/challenge-examples/tree/master/example/code_sql","title":"Example"},{"location":"challenge-types/vscode/","text":"VsCode challenge Do you feel restricted with other challenge types ? Do you want to let your student enjoys a full editor ? Let's do it with Deadlock in the browser! How ? You have to create the following files: \u251c\u2500\u2500 base \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u251c\u2500\u2500 main \u2502 \u2502 \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 io \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 deadlock \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 CdbApplication.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources / \u2502 \u2502 \u2514\u2500\u2500 test / \u2502 \u2514\u2500\u2500 webapp / \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 briefing.md \u2514\u2500\u2500 thumbnail.png base directory containing user files, those files will be delivered to the user when the IDE starts. docs contains the briefing, user instructions, the briefing will be opened when the IDE starts. Dockerfile FROM registry.e-biz.fr/deadlock-public/deadlock-theia:latest # You are free to install anything you want # The package manager is *apt* # destination paths are unchangeable COPY base /project # copy user directory to /project COPY docs /home/theia/docs # copy instructions challenge.yaml is the descriptor file version : 0.1 name : code_persist_crud label : Crud description : This is your moment, you have to create your own CRUD. Your customer requested you to build a Computer DataBase application (codename *CDB*). level : ewok # difficulty of the challenge [how it works](https://deadlock-resources.github.io/challenge-documentation/#level) type : PERSISTENT # mandatory xp : # xp tags, you are free to write your own programming : 1 # this is a weight, not a number java : 1 coding : userDirectory : base resources : # Resources given for the container, don't touch it if you are not comfortable with cpuLimit : \"1200m\" memoryLimit : \"1200Mi\" cpuRequest : \"1000m\" memoryRequest : \"1000Mi\" persistent : ports : # ports you want to let open for the user web : 3000 # mandatory crud : 9090 thumbnail.png image challenge Add image to the briefing ![toast](image:toast.jpg) ![Something Else](image:dir/else.png) You must prefix your image path with image: How to test ? > cd ./code_persist_crud > dcli run . Then it will give you an address you can click on it or copy paste in your browser. Add services on startup Let's say you need to start a service when the mission starts. For instance a Postgres database. You simply need to add a startup.sh script within your Docker image: COPY startup.sh /deadlock/startup.sh and within your startup.sh for instance: #!/bin/sh # Launch postgres service on startup service postgresql start The startup.sh script will be run when the Docker container starts. If you need to populate your database, it's better to do it within the Dockerfile (it will be faster than using the startup script): # Postgresql installation RUN apt-get -y update RUN apt-get -y install postgresql USER postgres COPY db/sql /sql # populate database RUN /etc/init.d/postgresql start && \\ psql --command \"CREATE USER deadlock WITH SUPERUSER PASSWORD 'no-passwd';\" && \\ createdb -O deadlock deadlock-db && \\ psql -d deadlock-db -U deadlock -f /sql/1__schema.sql -f /sql/2__entries.sql && \\","title":"VsCode"},{"location":"challenge-types/vscode/#vscode-challenge","text":"Do you feel restricted with other challenge types ? Do you want to let your student enjoys a full editor ? Let's do it with Deadlock in the browser!","title":"VsCode challenge"},{"location":"challenge-types/vscode/#how","text":"You have to create the following files: \u251c\u2500\u2500 base \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u251c\u2500\u2500 main \u2502 \u2502 \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 io \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 deadlock \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 CdbApplication.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources / \u2502 \u2502 \u2514\u2500\u2500 test / \u2502 \u2514\u2500\u2500 webapp / \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 briefing.md \u2514\u2500\u2500 thumbnail.png base directory containing user files, those files will be delivered to the user when the IDE starts. docs contains the briefing, user instructions, the briefing will be opened when the IDE starts. Dockerfile FROM registry.e-biz.fr/deadlock-public/deadlock-theia:latest # You are free to install anything you want # The package manager is *apt* # destination paths are unchangeable COPY base /project # copy user directory to /project COPY docs /home/theia/docs # copy instructions challenge.yaml is the descriptor file version : 0.1 name : code_persist_crud label : Crud description : This is your moment, you have to create your own CRUD. Your customer requested you to build a Computer DataBase application (codename *CDB*). level : ewok # difficulty of the challenge [how it works](https://deadlock-resources.github.io/challenge-documentation/#level) type : PERSISTENT # mandatory xp : # xp tags, you are free to write your own programming : 1 # this is a weight, not a number java : 1 coding : userDirectory : base resources : # Resources given for the container, don't touch it if you are not comfortable with cpuLimit : \"1200m\" memoryLimit : \"1200Mi\" cpuRequest : \"1000m\" memoryRequest : \"1000Mi\" persistent : ports : # ports you want to let open for the user web : 3000 # mandatory crud : 9090 thumbnail.png image challenge","title":"How ?"},{"location":"challenge-types/vscode/#add-image-to-the-briefing","text":"![toast](image:toast.jpg) ![Something Else](image:dir/else.png) You must prefix your image path with image:","title":"Add image to the briefing"},{"location":"challenge-types/vscode/#how-to-test","text":"> cd ./code_persist_crud > dcli run . Then it will give you an address you can click on it or copy paste in your browser.","title":"How to test ?"},{"location":"challenge-types/vscode/#add-services-on-startup","text":"Let's say you need to start a service when the mission starts. For instance a Postgres database. You simply need to add a startup.sh script within your Docker image: COPY startup.sh /deadlock/startup.sh and within your startup.sh for instance: #!/bin/sh # Launch postgres service on startup service postgresql start The startup.sh script will be run when the Docker container starts. If you need to populate your database, it's better to do it within the Dockerfile (it will be faster than using the startup script): # Postgresql installation RUN apt-get -y update RUN apt-get -y install postgresql USER postgres COPY db/sql /sql # populate database RUN /etc/init.d/postgresql start && \\ psql --command \"CREATE USER deadlock WITH SUPERUSER PASSWORD 'no-passwd';\" && \\ createdb -O deadlock deadlock-db && \\ psql -d deadlock-db -U deadlock -f /sql/1__schema.sql -f /sql/2__entries.sql && \\","title":"Add services on startup"},{"location":"mode/","text":"Sandbox There is also an other mission mode, sandbox one. Common mission must contains a list of test to allow the user to succeed the mission. But sometimes it can be painful or impossible to implement test to make sure the user understood and succeed well the challenge. So you can also create a mission without any test but you still have to create the Run class. The professor will be able to validate the mission via the student page. The only thing to add is sandboxed: true to the challenge.yaml file. Example: name : code_interview_card_game label : Card Game description : Card Game level : ewok type : CODING sandboxed : true Blacklist words By default there are some words the user cannot use into his code. You can find example into resources/default/blacklist . You can also create your own blacklist for your mission by creating a blacklist file next to the challenge.yaml, then fill it as a csv file. It also supports regex expressions. Example of blacklist file: [ ^<> ]( < | > )[ ^>< ] , ( System \\. exit \\( )( \\d ) * ( \\) ) , ( Runtime \\. getRuntime \\(\\)\\. exit \\(\\d * \\) )","title":"Mode"},{"location":"mode/#sandbox","text":"There is also an other mission mode, sandbox one. Common mission must contains a list of test to allow the user to succeed the mission. But sometimes it can be painful or impossible to implement test to make sure the user understood and succeed well the challenge. So you can also create a mission without any test but you still have to create the Run class. The professor will be able to validate the mission via the student page. The only thing to add is sandboxed: true to the challenge.yaml file. Example: name : code_interview_card_game label : Card Game description : Card Game level : ewok type : CODING sandboxed : true","title":"Sandbox"},{"location":"mode/#blacklist-words","text":"By default there are some words the user cannot use into his code. You can find example into resources/default/blacklist . You can also create your own blacklist for your mission by creating a blacklist file next to the challenge.yaml, then fill it as a csv file. It also supports regex expressions. Example of blacklist file: [ ^<> ]( < | > )[ ^>< ] , ( System \\. exit \\( )( \\d ) * ( \\) ) , ( Runtime \\. getRuntime \\(\\)\\. exit \\(\\d * \\) )","title":"Blacklist words"}]}