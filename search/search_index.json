{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Missions dans Deadlock Vue d'ensemble Cette documentation a pour but de vous guider dans la cr\u00e9ation de votre propre support d'apprentissage \u00e0 travers la plateforme Deadlock. Dans un premier temps nous allons aborder les missions dites 'classiques' mais il existe d'autre type de missions que vous retrouverez \u00e0 la fin de ce guide Une mission, c'est quoi ? Une mission est principalement compos\u00e9e des \u00e9l\u00e9ments suivants : Une documentation : les instructions pour l'utilisateur Un dossier template : le code fourni \u00e0 l'utilisateur Un dossier success : la solution de la mission Un dossier app : la logique pour v\u00e9rifier le code de l'utilisateur Un descripteur de mission : challenge.yml Plusieurs indices : vous pouvez ajouter diff\u00e9rents indices qui seront d\u00e9bloqu\u00e9s par l'utilisateur en utilisant des jetons L'interface utilisateur ressemble donc \u00e0 ceci : La documentation avec le briefing (informations principales) et les indices Le code fourni Le bouton Ex\u00e9cuter qui lance le code de l'utilisateur sans tests (v\u00e9rification de syntaxe, ...) Le bouton Soumettre qui ex\u00e9cute le code de l'utilisateur avec les tests Pour Commencer Chaque mission poss\u00e8de une structure sp\u00e9cifique fournie par notre outil DCLI . D\u00e9marrer une mission est assez facile, vous n'avez qu'\u00e0 vous soucier de ce que vous d\u00e9sirez fournir \u00e0 vos utilisateurs. Installation de DCLI Pr\u00e9-requis : Docker ( \u00e0 installer en non-root ) Python >= 3.2 pip install\u00e9 ( avec python ou depuis votre gestionnaire de package) Une fois les pr\u00e9-requis install\u00e9s vous pouvez installer le dcli via pip : pip3 install deadlock-cli Ensuite vous devriez pouvoir utiliser la commande dcli depuis votre terminal. Ex\u00e9cuter la commande dcli --help pour v\u00e9rifier que tout fonctionne. Si la console affiche un message du type command not found ou module not found quand vous ex\u00e9cuter la commande dcli , essayer d'exporter /home/user/.local/bin dans votre variable $PATH. > dcli --help # man page should be printed > dcli version current is 1 .2.0 Cr\u00e9er votre premier challenge Nous allons cr\u00e9er une mission Java pour expliquer le concept derri\u00e8re la structure. Java est utilis\u00e9 pour l'exemple, d\u00e8s que vous aurez compris l'architecture, vous serez en mesure de cr\u00e9er une mission dans n'importe quel langage. De plus dcli peut g\u00e9n\u00e9rer des missions dans d'autres langages, vous pouvez vous inspirer de nos exemples . Commen\u00e7ons par l'exemple Java : > dcli gen java Nous allons cr\u00e9er une mission simple o\u00f9 l'utilisateur doit juste afficher Hello World! . Explorons le dossier g\u00e9n\u00e9r\u00e9 code_hello_world par dcli : code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Run.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png La mission est simple, impl\u00e9menter la m\u00e9thode sayHello() au sein du package template . Tous les fichiers dans le package template seront fournis \u00e0 l'utilisateur, vous pouvez en cr\u00e9er autant que vous le d\u00e9sirez. Le fichier HelloWorld.java dans le package success ne sera fourni \u00e0 l'utilisateur que lorsqu'il aura r\u00e9ussi la mission. Vous devez r\u00e9soudre tous les //TODO pr\u00e9sents dans le code. Commen\u00e7ons par src/main/java/success/HelloWorld.java , il s'agit du fichier de solution. public static String sayHello () { //TODO write your own solution return null ; } La m\u00e9thode doit simplement retourner \"Hello World!\" . L'\u00e9tape suivante consiste \u00e0 comparer le r\u00e9sultat de l'utilisateur avec le r\u00e9sultat attendu, cela est effectu\u00e9 dans src/main/java/app/Solve.java . DCLI g\u00e9n\u00e8re certaines parties de code pour vous, mais vous devrez le compl\u00e9ter avec votre propre algorithme. public static void main ( String [] args ) { try { // user result String userResult = HelloWorld . sayHello (); // your solution result String expectedResult = success . HelloWorld . sayHello (); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if ( expectedResult . equals ( userResult )) { // if all test passed successfully Logger . logSuccess (); } else { Logger . logFail ( expectedResult , userResult ); System . exit ( 1 ); } } catch ( RuntimeException e ) { Logger . logException ( e ); // if something bad happened exit with error code System . exit ( 1 ); } } Le code ci-dessus logue une erreur et s'arr\u00eate avec un code d'erreur si la fonction HelloWorld.sayHello() ne retourne pas \"Hello World!\" ou si elle lance une exception. En g\u00e9n\u00e9ral, il y a 2 types de r\u00e9sultats que vous devez prendre en consid\u00e9ration. Error : Le code ne compile pas, la fonction n'a pas la bonne signature, le code ne retourne pas le r\u00e9sultat attendu, quelque chose d'autre s'est mal pass\u00e9. Success : Le code compile, s'est termin\u00e9 normalement et retourne le r\u00e9sultat attendu. Une simple classe Logger est \u00e9galement g\u00e9n\u00e9r\u00e9e. Vous pouvez maintenant tester votre mission avec les commandes suivantes : > cd ./code_hello_world > dcli run . # Run the program, execute the file `src/main/java/app/Run.java` > dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` Essayer de modifier le fichier HelloWorld.java du package template pour compl\u00e9ter la mission comme si vous \u00e9tiez un candidat. Documentation La documentation de la mission est disponible dans code_hello_world/docs/ . Elle contient le briefing qui expose le probl\u00e8me que le candidat doit r\u00e9soudre. Le briefing doit \u00eatre contextualis\u00e9 pour respecter la gamification propre \u00e0 Deadlock. Le briefing doit \u00eatre \u00e9crit en Markdown, il peut contenir des balises HTML ou \u00eatre \u00e9crit en langage LateX. briefing.md : contient les instructions de base de la mission debriefing.md : contient le texte affich\u00e9 quand l'utilisateur r\u00e9sout la mission hint1.md : premier indice que le candidat peut d\u00e9bloquer (optionnel) hint2.md : un autre indice (optionnel) Exemple d'indices : hint1.md La cha\u00eene de caract\u00e8re que vous devez retourner n'est rien d'autre que les deux mots que vous affichez lorsque vous apprenez un nouveau langage. On peut le consid\u00e9rer comme un message de bienvenue. (PS : la solution n'est pas \"It works\"). hint2.md La cha\u00eene de caract\u00e8re attendue est sensible \u00e0 la casse, vous devriez essayer plusieurs casses. De plus, nous nous sommes enflamm\u00e9s en \u00e9crivant cette mission et nous avons d\u00e9cid\u00e9 de ponctuer la solution avec une \"!\". N.B. : l'ordre des indices a une importance (le second indice ne peut \u00eatre d\u00e9bloqu\u00e9 que si le premier a \u00e9t\u00e9 d\u00e9bloqu\u00e9). A ce stade, nous avons une application Java fonctionnelle qui va tester le contenu d'une classe compil\u00e9 HelloWorld.class et retourner un code d'erreur ou de succ\u00e8s. Si vous voulez aller plus loin en comprenant le fonctionnement des missions pour les personnaliser encore plus, vous pouvez lire ceci . i18n Le dossier docs contient par d\u00e9faut les fichiers pour la traduction anglaise de la mission. Si vous voulez supporter d'autres langues, vous devez cr\u00e9er un nouveau dossier par langue en suivant cette arborescence : \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md et ainsi de suite. Niveau Chaque mission \u00e0 son propre niveau de complexit\u00e9 Jajarbinks (le plus facile) Ewok Padawan Jedi Master (le plus difficile) Quand vous cr\u00e9ez votre propre mission, vous pouvez vous appuyer sur nos missions de r\u00e9f\u00e9rence pour renseigner le bon niveau \u00e0 votre mission. Et apr\u00e8s ? Vous pouvez explorer les diff\u00e9rents types de missions propos\u00e9es dans Deadlock : VsCode Multi-langage Multi-service Score SQL","title":"Missions dans Deadlock"},{"location":"#missions-dans-deadlock","text":"","title":"Missions dans Deadlock"},{"location":"#vue-densemble","text":"Cette documentation a pour but de vous guider dans la cr\u00e9ation de votre propre support d'apprentissage \u00e0 travers la plateforme Deadlock. Dans un premier temps nous allons aborder les missions dites 'classiques' mais il existe d'autre type de missions que vous retrouverez \u00e0 la fin de ce guide","title":"Vue d'ensemble"},{"location":"#une-mission-cest-quoi","text":"Une mission est principalement compos\u00e9e des \u00e9l\u00e9ments suivants : Une documentation : les instructions pour l'utilisateur Un dossier template : le code fourni \u00e0 l'utilisateur Un dossier success : la solution de la mission Un dossier app : la logique pour v\u00e9rifier le code de l'utilisateur Un descripteur de mission : challenge.yml Plusieurs indices : vous pouvez ajouter diff\u00e9rents indices qui seront d\u00e9bloqu\u00e9s par l'utilisateur en utilisant des jetons L'interface utilisateur ressemble donc \u00e0 ceci : La documentation avec le briefing (informations principales) et les indices Le code fourni Le bouton Ex\u00e9cuter qui lance le code de l'utilisateur sans tests (v\u00e9rification de syntaxe, ...) Le bouton Soumettre qui ex\u00e9cute le code de l'utilisateur avec les tests","title":"Une mission, c'est quoi ?"},{"location":"#pour-commencer","text":"Chaque mission poss\u00e8de une structure sp\u00e9cifique fournie par notre outil DCLI . D\u00e9marrer une mission est assez facile, vous n'avez qu'\u00e0 vous soucier de ce que vous d\u00e9sirez fournir \u00e0 vos utilisateurs.","title":"Pour Commencer"},{"location":"#installation-de-dcli","text":"Pr\u00e9-requis : Docker ( \u00e0 installer en non-root ) Python >= 3.2 pip install\u00e9 ( avec python ou depuis votre gestionnaire de package) Une fois les pr\u00e9-requis install\u00e9s vous pouvez installer le dcli via pip : pip3 install deadlock-cli Ensuite vous devriez pouvoir utiliser la commande dcli depuis votre terminal. Ex\u00e9cuter la commande dcli --help pour v\u00e9rifier que tout fonctionne. Si la console affiche un message du type command not found ou module not found quand vous ex\u00e9cuter la commande dcli , essayer d'exporter /home/user/.local/bin dans votre variable $PATH. > dcli --help # man page should be printed > dcli version current is 1 .2.0","title":"Installation de DCLI"},{"location":"#creer-votre-premier-challenge","text":"Nous allons cr\u00e9er une mission Java pour expliquer le concept derri\u00e8re la structure. Java est utilis\u00e9 pour l'exemple, d\u00e8s que vous aurez compris l'architecture, vous serez en mesure de cr\u00e9er une mission dans n'importe quel langage. De plus dcli peut g\u00e9n\u00e9rer des missions dans d'autres langages, vous pouvez vous inspirer de nos exemples . Commen\u00e7ons par l'exemple Java : > dcli gen java Nous allons cr\u00e9er une mission simple o\u00f9 l'utilisateur doit juste afficher Hello World! . Explorons le dossier g\u00e9n\u00e9r\u00e9 code_hello_world par dcli : code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Run.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png La mission est simple, impl\u00e9menter la m\u00e9thode sayHello() au sein du package template . Tous les fichiers dans le package template seront fournis \u00e0 l'utilisateur, vous pouvez en cr\u00e9er autant que vous le d\u00e9sirez. Le fichier HelloWorld.java dans le package success ne sera fourni \u00e0 l'utilisateur que lorsqu'il aura r\u00e9ussi la mission. Vous devez r\u00e9soudre tous les //TODO pr\u00e9sents dans le code. Commen\u00e7ons par src/main/java/success/HelloWorld.java , il s'agit du fichier de solution. public static String sayHello () { //TODO write your own solution return null ; } La m\u00e9thode doit simplement retourner \"Hello World!\" . L'\u00e9tape suivante consiste \u00e0 comparer le r\u00e9sultat de l'utilisateur avec le r\u00e9sultat attendu, cela est effectu\u00e9 dans src/main/java/app/Solve.java . DCLI g\u00e9n\u00e8re certaines parties de code pour vous, mais vous devrez le compl\u00e9ter avec votre propre algorithme. public static void main ( String [] args ) { try { // user result String userResult = HelloWorld . sayHello (); // your solution result String expectedResult = success . HelloWorld . sayHello (); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if ( expectedResult . equals ( userResult )) { // if all test passed successfully Logger . logSuccess (); } else { Logger . logFail ( expectedResult , userResult ); System . exit ( 1 ); } } catch ( RuntimeException e ) { Logger . logException ( e ); // if something bad happened exit with error code System . exit ( 1 ); } } Le code ci-dessus logue une erreur et s'arr\u00eate avec un code d'erreur si la fonction HelloWorld.sayHello() ne retourne pas \"Hello World!\" ou si elle lance une exception. En g\u00e9n\u00e9ral, il y a 2 types de r\u00e9sultats que vous devez prendre en consid\u00e9ration. Error : Le code ne compile pas, la fonction n'a pas la bonne signature, le code ne retourne pas le r\u00e9sultat attendu, quelque chose d'autre s'est mal pass\u00e9. Success : Le code compile, s'est termin\u00e9 normalement et retourne le r\u00e9sultat attendu. Une simple classe Logger est \u00e9galement g\u00e9n\u00e9r\u00e9e. Vous pouvez maintenant tester votre mission avec les commandes suivantes : > cd ./code_hello_world > dcli run . # Run the program, execute the file `src/main/java/app/Run.java` > dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` Essayer de modifier le fichier HelloWorld.java du package template pour compl\u00e9ter la mission comme si vous \u00e9tiez un candidat.","title":"Cr\u00e9er votre premier challenge"},{"location":"#documentation","text":"La documentation de la mission est disponible dans code_hello_world/docs/ . Elle contient le briefing qui expose le probl\u00e8me que le candidat doit r\u00e9soudre. Le briefing doit \u00eatre contextualis\u00e9 pour respecter la gamification propre \u00e0 Deadlock. Le briefing doit \u00eatre \u00e9crit en Markdown, il peut contenir des balises HTML ou \u00eatre \u00e9crit en langage LateX. briefing.md : contient les instructions de base de la mission debriefing.md : contient le texte affich\u00e9 quand l'utilisateur r\u00e9sout la mission hint1.md : premier indice que le candidat peut d\u00e9bloquer (optionnel) hint2.md : un autre indice (optionnel) Exemple d'indices : hint1.md La cha\u00eene de caract\u00e8re que vous devez retourner n'est rien d'autre que les deux mots que vous affichez lorsque vous apprenez un nouveau langage. On peut le consid\u00e9rer comme un message de bienvenue. (PS : la solution n'est pas \"It works\"). hint2.md La cha\u00eene de caract\u00e8re attendue est sensible \u00e0 la casse, vous devriez essayer plusieurs casses. De plus, nous nous sommes enflamm\u00e9s en \u00e9crivant cette mission et nous avons d\u00e9cid\u00e9 de ponctuer la solution avec une \"!\". N.B. : l'ordre des indices a une importance (le second indice ne peut \u00eatre d\u00e9bloqu\u00e9 que si le premier a \u00e9t\u00e9 d\u00e9bloqu\u00e9). A ce stade, nous avons une application Java fonctionnelle qui va tester le contenu d'une classe compil\u00e9 HelloWorld.class et retourner un code d'erreur ou de succ\u00e8s. Si vous voulez aller plus loin en comprenant le fonctionnement des missions pour les personnaliser encore plus, vous pouvez lire ceci .","title":"Documentation"},{"location":"#i18n","text":"Le dossier docs contient par d\u00e9faut les fichiers pour la traduction anglaise de la mission. Si vous voulez supporter d'autres langues, vous devez cr\u00e9er un nouveau dossier par langue en suivant cette arborescence : \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md et ainsi de suite.","title":"i18n"},{"location":"#niveau","text":"Chaque mission \u00e0 son propre niveau de complexit\u00e9 Jajarbinks (le plus facile) Ewok Padawan Jedi Master (le plus difficile) Quand vous cr\u00e9ez votre propre mission, vous pouvez vous appuyer sur nos missions de r\u00e9f\u00e9rence pour renseigner le bon niveau \u00e0 votre mission.","title":"Niveau"},{"location":"#et-apres","text":"Vous pouvez explorer les diff\u00e9rents types de missions propos\u00e9es dans Deadlock : VsCode Multi-langage Multi-service Score SQL","title":"Et apr\u00e8s ?"},{"location":"contributing/","text":"Aider \u00e0 b\u00e2tir Deadlock Ceci est une introduction \u00e0 la contribution sur le projet Deadlock. Vous pouvez contribuer de plusieurs mani\u00e8res, par exemple : En am\u00e9liorant le code par des pull-requests En am\u00e9liorant la documentation En rapportant des bugs ou en participants aux codes review des patchs Vous pouvez contribuer sur les projets suivants : Exemples de missions Documentation des missions Dcli Vous pouvez \u00e9galement retrouver des ressources, des exemples et contribuer \u00e0 l'am\u00e9lioration de Deadlock ici","title":"Contribuer"},{"location":"contributing/#aider-a-batir-deadlock","text":"Ceci est une introduction \u00e0 la contribution sur le projet Deadlock. Vous pouvez contribuer de plusieurs mani\u00e8res, par exemple : En am\u00e9liorant le code par des pull-requests En am\u00e9liorant la documentation En rapportant des bugs ou en participants aux codes review des patchs Vous pouvez contribuer sur les projets suivants : Exemples de missions Documentation des missions Dcli Vous pouvez \u00e9galement retrouver des ressources, des exemples et contribuer \u00e0 l'am\u00e9lioration de Deadlock ici","title":"Aider \u00e0 b\u00e2tir Deadlock"},{"location":"help/","text":"Pour obtenir de l'aide sur les Missions Deadlock, vous pouvez soumettre une issue sur le github des missions ou soumettre une issue sur le github de la documentation des missions .","title":"Besoin d'aide"},{"location":"how-does-it-work/","text":"Comment \u00e7a marche ? Si vous \u00eates ici, nous supposons que vous avez d\u00e9j\u00e0 parcouru les bases et vous d\u00e9sirez en apprendre plus sur comment une mission fonctionne. Nous allons vous expliquer l'utilit\u00e9 de tous les fichiers d'une mission. Pour \u00eatre \u00e0 l'aise avec la suite, vous devez poss\u00e9der les bases en : Docker Fichier Yaml Dockerfile Quand un candidat soumet son code, un conteneur Docker est cr\u00e9\u00e9. Le nom de l'image Docker sera le nom de votre mission pr\u00e9fix\u00e9e de code_ . Important : Vous devez d\u00e9finir CMD et ENTRYPOINT sp\u00e9cifiquement pour votre conteneur. Avant l'ex\u00e9cution de votre conteneur, le code du candidat est coll\u00e9 dans le dossier template . L'emplacement et le contenu de ce fichier vous est propre et doit \u00eatre soumis dans le descripteur . Une fois le code d\u00e9ploy\u00e9 dans le conteneur, ce dernier va s'ex\u00e9cuter jusqu'\u00e0 la fin de vos instructions. Rappelez-vous que les signaux STDOUT et STDERR seront affich\u00e9s dans la console du candidat. Une fois termin\u00e9, le code de sortie est v\u00e9rifi\u00e9. Si le code de sortie est 0 , la mission est un succ\u00e8s . Sinon , cela veut dire que le candidat a \u00e9chou\u00e9 . Vous pouvez personnaliser le Dockerfile \u00e0 volont\u00e9 en incluant par exemple des librairies externes pour permettre au candidat d'avoir acc\u00e8s \u00e0 encore plus de fonctionnalit\u00e9s ! Exemple d'une mission python incluant les librairies nymphy, sklearn et pandas FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [ \"/run.sh\" ] L'\u00e9tape de build est effectu\u00e9e une foi seulement lorsque la mission est accept\u00e9e par l'\u00e9quipe Deadlock. Descripteur de mission Chaque mission a son propre descripteur disponible dans challengename/challenge.yml. Il est utilis\u00e9 pour cr\u00e9er le conteneur de mission et r\u00e9cup\u00e9rer les sp\u00e9cificit\u00e9s de la mission concernant les langages et fichiers cibles version: 1 .0 # A incr\u00e9menter si le code \u00e9volue name: code_halloween_candy # Le nom de la missions. Il DOIT \u00eatre identique au nom du dossier de la mission label: Halloween Candy # Le libell\u00e9 de la mission description: Help your brother split his halloween candy # La description de la mission en anglais level: jarjarbinks # Le niveau de la mission. Du plus facile au plus difficile : jarjarbinks, ewok, padawan, jedi, master type: CODING # Le type de la mission. Ici : coding game meta: private: true # Si true, la mission sera uniquement visible sur votre instance \"ecole.deadlock.io), par d\u00e9faut : false --> visible par tout le monde. xp: # le nombre de points d'exp\u00e9rience que cette mission rapporte dans chaque domaine list\u00e9 en dessous programming: 1 # Il s'agit d'un poids et non d'un simple nombre. java: 1 coding: # Sp\u00e9cifique au challenge de type code templateDirectory: src/java/main/template # Le code fournit au candidat successDirectory: src/java/main/success # La solution de la mission target: CandySplitter.java # Le path du fichier cible consid\u00e9r\u00e9 comme fichier Main editorMode: java # Le langage \u00e0 afficher dans l'\u00e9diteur Web","title":"Comment \u00e7a marche ?"},{"location":"how-does-it-work/#comment-ca-marche","text":"Si vous \u00eates ici, nous supposons que vous avez d\u00e9j\u00e0 parcouru les bases et vous d\u00e9sirez en apprendre plus sur comment une mission fonctionne. Nous allons vous expliquer l'utilit\u00e9 de tous les fichiers d'une mission. Pour \u00eatre \u00e0 l'aise avec la suite, vous devez poss\u00e9der les bases en : Docker Fichier Yaml","title":"Comment \u00e7a marche ?"},{"location":"how-does-it-work/#dockerfile","text":"Quand un candidat soumet son code, un conteneur Docker est cr\u00e9\u00e9. Le nom de l'image Docker sera le nom de votre mission pr\u00e9fix\u00e9e de code_ . Important : Vous devez d\u00e9finir CMD et ENTRYPOINT sp\u00e9cifiquement pour votre conteneur. Avant l'ex\u00e9cution de votre conteneur, le code du candidat est coll\u00e9 dans le dossier template . L'emplacement et le contenu de ce fichier vous est propre et doit \u00eatre soumis dans le descripteur . Une fois le code d\u00e9ploy\u00e9 dans le conteneur, ce dernier va s'ex\u00e9cuter jusqu'\u00e0 la fin de vos instructions. Rappelez-vous que les signaux STDOUT et STDERR seront affich\u00e9s dans la console du candidat. Une fois termin\u00e9, le code de sortie est v\u00e9rifi\u00e9. Si le code de sortie est 0 , la mission est un succ\u00e8s . Sinon , cela veut dire que le candidat a \u00e9chou\u00e9 . Vous pouvez personnaliser le Dockerfile \u00e0 volont\u00e9 en incluant par exemple des librairies externes pour permettre au candidat d'avoir acc\u00e8s \u00e0 encore plus de fonctionnalit\u00e9s ! Exemple d'une mission python incluant les librairies nymphy, sklearn et pandas FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [ \"/run.sh\" ] L'\u00e9tape de build est effectu\u00e9e une foi seulement lorsque la mission est accept\u00e9e par l'\u00e9quipe Deadlock.","title":"Dockerfile"},{"location":"how-does-it-work/#descripteur-de-mission","text":"Chaque mission a son propre descripteur disponible dans challengename/challenge.yml. Il est utilis\u00e9 pour cr\u00e9er le conteneur de mission et r\u00e9cup\u00e9rer les sp\u00e9cificit\u00e9s de la mission concernant les langages et fichiers cibles version: 1 .0 # A incr\u00e9menter si le code \u00e9volue name: code_halloween_candy # Le nom de la missions. Il DOIT \u00eatre identique au nom du dossier de la mission label: Halloween Candy # Le libell\u00e9 de la mission description: Help your brother split his halloween candy # La description de la mission en anglais level: jarjarbinks # Le niveau de la mission. Du plus facile au plus difficile : jarjarbinks, ewok, padawan, jedi, master type: CODING # Le type de la mission. Ici : coding game meta: private: true # Si true, la mission sera uniquement visible sur votre instance \"ecole.deadlock.io), par d\u00e9faut : false --> visible par tout le monde. xp: # le nombre de points d'exp\u00e9rience que cette mission rapporte dans chaque domaine list\u00e9 en dessous programming: 1 # Il s'agit d'un poids et non d'un simple nombre. java: 1 coding: # Sp\u00e9cifique au challenge de type code templateDirectory: src/java/main/template # Le code fournit au candidat successDirectory: src/java/main/success # La solution de la mission target: CandySplitter.java # Le path du fichier cible consid\u00e9r\u00e9 comme fichier Main editorMode: java # Le langage \u00e0 afficher dans l'\u00e9diteur Web","title":"Descripteur de mission"},{"location":"reference/","text":"R\u00e9f\u00e9rences pour le niveau des missions Vous trouverez ici quelques exemples de missions existantes. Un niveau de difficult\u00e9 a \u00e9t\u00e9 assign\u00e9 \u00e0 chacune d'elles, vous pouvez utiliser ce classement pour positionner le niveau de difficult\u00e9 de votre mission parmi les cinq niveaux propos\u00e9s Jajarbinks Ewok Padawan Jedi Master Let's dance Collision box in da box Game of Life Collision circle vs segment Mario Needs Help Romanizer Fibo challenge Midnight Club Basics 2 Military Satellite Caesar Decipher The Secret Message Recommendation Netflix Out of pub","title":"R\u00e9f\u00e9rences pour le niveau des missions"},{"location":"reference/#references-pour-le-niveau-des-missions","text":"Vous trouverez ici quelques exemples de missions existantes. Un niveau de difficult\u00e9 a \u00e9t\u00e9 assign\u00e9 \u00e0 chacune d'elles, vous pouvez utiliser ce classement pour positionner le niveau de difficult\u00e9 de votre mission parmi les cinq niveaux propos\u00e9s Jajarbinks Ewok Padawan Jedi Master Let's dance Collision box in da box Game of Life Collision circle vs segment Mario Needs Help Romanizer Fibo challenge Midnight Club Basics 2 Military Satellite Caesar Decipher The Secret Message Recommendation Netflix Out of pub","title":"R\u00e9f\u00e9rences pour le niveau des missions"},{"location":"submit/","text":"En tant que professeur, vous pouvez soumettre votre mission sur https://takima.deadlock.io/missions/upload Si vous avez des questions ou besoin d'aide, nous sommes ici","title":"Soumission"},{"location":"challenge-types/code/","text":"Exemples de mission de code Voici plusieurs exemples de missions pour diff\u00e9rents langages : Exemple en C Exemple en Cpp Exemple en Java Exemple en Java Maven Exemple en Ocaml Exemple en Python Exemple en Python (score) Exemple en SQL","title":"Exemples"},{"location":"challenge-types/code/#exemples-de-mission-de-code","text":"Voici plusieurs exemples de missions pour diff\u00e9rents langages : Exemple en C Exemple en Cpp Exemple en Java Exemple en Java Maven Exemple en Ocaml Exemple en Python Exemple en Python (score) Exemple en SQL","title":"Exemples de mission de code"},{"location":"challenge-types/java_maven/","text":"Java Maven Lorsque vous cr\u00e9ez une mission Java Maven, vous devez t\u00e9l\u00e9charger toutes les d\u00e9pendances du projet dans un fichier build.sh en utilisant Maven. #!/bin/sh # Script ex\u00e9cut\u00e9 avant le build de l'image Docker # T\u00e9l\u00e9charge toutes le d\u00e9pendances du projet pour les ajouter \u00e0 l'image Docker via le Dockerfile # Ici, nous avons d\u00e9fini nos d\u00e9pendances dans un jar mvn -B dependency:copy-dependencies -DoutputDirectory = jar Ensuite, les d\u00e9pendances sont ajout\u00e9 au Dockerfile # Ajoute les jars de toutes les d\u00e9pendances ADD jar src/main/java/jar Fichier Challenge.yml Vou devez compl\u00e9ter le fichier challenge.yaml : version : 1.0 name : code_calculator label : Calculator challenge description : Implement calculator operations level : ewok type : CODING xp : java : 1 programming : 1 coding : templateDirectory : src/main/java/template successDirectory : src/main/java/success target : Calculator.java editorMode : java Dossier Template et Success Le dossier template/ contient le code \u00e9crit par le candidat tentant de r\u00e9soudre la mission. Le dossier success/ contient votre solution qui sera donn\u00e9e au candidat lorsqu'il aura r\u00e9ussi la mission. Vous pouvez fournir l'impl\u00e9mentation de solution que vous d\u00e9sirez. Pour tester votre programme, vous pouvez utiliser notre CLI : > dcli run . # Ex\u00e9cture template/ > dcli solve . # Ex\u00e9cute les tests de template/ Exemple d'arborescence d'une mission Java Maven \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 jar \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Run.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2514\u2500\u2500 success \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java Exemple code_java_maven","title":"Java Maven"},{"location":"challenge-types/java_maven/#java-maven","text":"Lorsque vous cr\u00e9ez une mission Java Maven, vous devez t\u00e9l\u00e9charger toutes les d\u00e9pendances du projet dans un fichier build.sh en utilisant Maven. #!/bin/sh # Script ex\u00e9cut\u00e9 avant le build de l'image Docker # T\u00e9l\u00e9charge toutes le d\u00e9pendances du projet pour les ajouter \u00e0 l'image Docker via le Dockerfile # Ici, nous avons d\u00e9fini nos d\u00e9pendances dans un jar mvn -B dependency:copy-dependencies -DoutputDirectory = jar Ensuite, les d\u00e9pendances sont ajout\u00e9 au Dockerfile # Ajoute les jars de toutes les d\u00e9pendances ADD jar src/main/java/jar","title":"Java Maven"},{"location":"challenge-types/java_maven/#fichier-challengeyml","text":"Vou devez compl\u00e9ter le fichier challenge.yaml : version : 1.0 name : code_calculator label : Calculator challenge description : Implement calculator operations level : ewok type : CODING xp : java : 1 programming : 1 coding : templateDirectory : src/main/java/template successDirectory : src/main/java/success target : Calculator.java editorMode : java","title":"Fichier Challenge.yml"},{"location":"challenge-types/java_maven/#dossier-template-et-success","text":"Le dossier template/ contient le code \u00e9crit par le candidat tentant de r\u00e9soudre la mission. Le dossier success/ contient votre solution qui sera donn\u00e9e au candidat lorsqu'il aura r\u00e9ussi la mission. Vous pouvez fournir l'impl\u00e9mentation de solution que vous d\u00e9sirez. Pour tester votre programme, vous pouvez utiliser notre CLI : > dcli run . # Ex\u00e9cture template/ > dcli solve . # Ex\u00e9cute les tests de template/","title":"Dossier Template et Success"},{"location":"challenge-types/java_maven/#exemple-darborescence-dune-mission-java-maven","text":"\u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 jar \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Run.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2514\u2500\u2500 success \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 Calculator.java \u2502 \u2514\u2500\u2500 CalculatorTest.java","title":"Exemple d'arborescence d'une mission Java Maven"},{"location":"challenge-types/java_maven/#exemple","text":"code_java_maven","title":"Exemple"},{"location":"challenge-types/metamorph/","text":"Multi-langage (metamorph) Vous pouvez cr\u00e9er une mission ind\u00e9pendamment du langage dans lequel elle sera r\u00e9solue. Le candidat est donc libre de choisir son langage pr\u00e9f\u00e9r\u00e9 pour r\u00e9soudre le probl\u00e8me ! Liste des langages support\u00e9s par Deadlock : Java 11.0.5 (openjdk) Kotlin 1.3.70-eap-184 Python 3.8.2 C/C++ 9.2.0 Rust 1.39.0 Go 1.12.16 Javascript avec NodeJS 12.15.0 Ruby 2.6.6 Ocaml 4.08.1 Imaginons que vous souhaitez \u00e9crire une mission d'impl\u00e9mentation de la suite de Fibonacci. Cr\u00e9er un nouveau dossier contenant un fichier entry.rs . Ce fichier d\u00e9finit : quel(s) langage(s) sont disponibles pour l'impl\u00e9mentation de la r\u00e9solution du candidat, tous les tests pour valider le code du candidat. 1 2 3 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ] }} Dans le premier tableau sont \u00e9num\u00e9r\u00e9 tous les langages que le candidat pourra s\u00e9lectionner au moment de d\u00e9velopper la solution \u00e0 la mission. Ensuite, vous devez \u00e9crire diff\u00e9rents tests, chacun sera ex\u00e9cut\u00e9 seulement si le pr\u00e9c\u00e9dent r\u00e9ussi. Ecrivons ensemble le premier ! 1 2 3 4 5 6 7 8 9 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 } ] }} Ce test va appeler le programme du candidat avec 0 comme entr\u00e9e et s'attend \u00e0 avoir 1 comme sortie . Par d\u00e9faut, pour chaque langage, le candidat dispose d'un template. Vous pouvez personnaliser le template pour chaque langage : Java Javascript Python Go C Cpp Ocaml Rust Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { if ( args . length > 0 ) { // Called when you submit your code. System . out . println ( fibonacci ( Long . ValueOf ( args [ 0 ] ))); } else { // Called when you run your code. System . out . println ( \"Hello World!\" ); } } public static long fibonacci ( long n ) { return n ; } } 1 2 3 4 5 6 7 8 9 10 11 12 // CommonJS if ( process . argv . length > 2 ) { // args given, code submitted console . log ( fibonacci ( process . argv [ 2 ])); } else { // no given, code ran console . log ( \"Hello World!\" ); } function fibonacci ( n ) { return n ; } 1 2 3 4 5 6 7 8 9 10 11 import sys ; def fibonacci ( n ): return n if ( len ( sys . argv ) > 1 ): # args given, code submitted print ( fibonacci ( sys . argv [ 1 ])) else : # no given, code ran print ( \"Hello World!\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"os\" ) func Fibonacci ( n int64 ) int64 { return n } func main () { if ( len ( os . Args ) > 1 ) { // args given, code submitted arg := os . Args [ 1 ] fmt . Println ( Fibonacci ( arg )) } else { // no given, code ran fmt . Println ( \"Hello World!\" ) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <stdlib.h> long fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( argv [ 1 ])); } else { // no given, code ran printf ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <bits/stdc++.h> bool fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( stol ( argv [ 1 ]))) } else { // no given, code ran printf ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 let fibonacci n = let rec fib_2termes n a b = match n with | 0 -> a | 1 -> b | _ -> fib_2termes ( n - 1 ) b ( a + b ) in fib_2termes n 0 1 ;; if Array . length Sys . argv > 1 = true then print_int ( fibonacci ( int_of_string Sys . argv .( 1 )));; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); if args . len () == 2 { // Called when you submit your code. println! ( \"{}\" , fibonacci ( & args [ 1 ])) } else { // Called when you run your code. println! ( \"Hello World!\" ) } } fn fibonacci ( n : i64 ) -> i64 { n } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main def initialize if ( ARGV . length () > 0 ) then puts fibonacci ( ARGV [ 0 ]. to_i ) # args given, code submitted else puts \"Hello World!\" # no args given, code runner end end def fibonacci ( n ) 0 end end # initialize object Main . new L'utilisateur doit compl\u00e9ter la m\u00e9thode fibonacci et le r\u00e9sultat sera affich\u00e9 dans le stdout (console). Continuons avec plus de tests : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 }, { input : 1 , expected : 1 }, { input : 2 , expected : 2 }, { input : 3 , expected : 3 }, { input : 10 , expected : 89 } ] }} Tests al\u00e9atoires Cela vous semble trop statique ? Vous pouvez ajouter des tests plus complexe avec des entr\u00e9es al\u00e9atoires en utilisant la m\u00e9thode random fournie par notre runner : randt(n) : g\u00e9n\u00e8re un nombre al\u00e9atoire entre 0 et n exclu. randft(n, m) : gn\u00e8re un nombre al\u00e9atoire entre n et m exclu. 1 2 3 4 { input : randft ( 20 , 30 ), expected : ? } Cela pose un probl\u00e8me. Que devons nous \u00e9crire dans la valeur attendue ? Pas de panique, vous pouvez appeler votre propre solution au lieu d'\u00e9crire une r\u00e9ponse attendue statique ! 1 2 3 4 5 6 7 8 { input : randft ( 20 , 30 ), expected : call ( \"java\" , \"Solution.java\" ) }, { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ) } La m\u00eame logique est appliqu\u00e9e, votre solution.py est appel\u00e9e par notre interpr\u00e8teur Python avec les donn\u00e9es de input et vous devez \u00e9crire le r\u00e9sultat renvoy\u00e9 par votre solution dans le stdout . Par exemple pour la suite de Fibonnaci : 1 2 3 4 5 6 7 8 # solution.py def fibo ( n ): if n <= 1 : return n else : return ( fibo ( n - 1 ) + fibo ( n - 2 )) print ( fibo ( sys . argv [ 1 ])) Ensuite la sortie stdout donn\u00e9e avec la m\u00e9thode print est compar\u00e9e \u00e0 celle r\u00e9sultant du programme du candidat. Vous pouvez choisir un interpr\u00e8teur parmi la liste de ceux propos\u00e9 ci-apr\u00e8s : java javascript ruby c rust python go cpp R\u00e9p\u00e9tition Qu'en est-il si vous d\u00e9sirez ex\u00e9cuter 50 tests al\u00e9atoire \u00e0 la suite ? Ce n'est pas un probl\u00e8me, tout ce que vous avez \u00e0 faire est d'ajouter le param\u00e8tre repeat \u00e0 votre test : { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ), repeat : 50 } Valeur d'entr\u00e9e Ce n'est pas tout, vous pouvez aussi appeler votre propre programme pour g\u00e9n\u00e9rer les valeurs d'entr\u00e9e : { input : call ( \"javascript\" , \"generate.js\" ), expected : call ( \"python\" , \"solution.py\" ) } Ouvrir un ficher Vous pouvez \u00e9galement ouvrir un fichier : { input : open ( \"file.txt\" ), expected : call ( \"python\" , \"solution.py\" ) } Il sera servi au candidat en tant que Cha\u00eene de caract\u00e8re . D\u00e8s que vous aurez compl\u00e9ter le fichier entry.rs , il faut compl\u00e9ter le fichier challenge.yaml : version : 1.0 name : code_metamorph_fibo label : Fibonacci description : Implements Fibonacci algorithm level : ewok type : CODING metamorph : true xp : programming : 1 coding : templateDirectory : /opt/runner successDirectory : success/ target : main.rs editorMode : rust Le dossier success/ contient votre solution qui sera donn\u00e9e au candidat lorsqu'il aura r\u00e9solu le probl\u00e8me de la mission. Vous \u00eates libre de choisir le langage et la logique d'impl\u00e9mentation de votre solution. Pour tester votre programme, vous pouvez utiliser notre CLI : > dcli run . java # Ex\u00e9cute template/java/Main.java > dcli solve . java # Ex\u00e9cute les tests sur template/java/Main.java > dcli run . python # Ex\u00e9cute template/python/Main.py Chaque fichier placer dans le dossier template est donn\u00e9 au candidat lorsqu'il d\u00e9cide de changer le langage selectionn\u00e9. Par exemple, si le candidat d\u00e9cide d'utiliser l'interpr\u00e9teur Rust , tous les fichier contenu dans template/rust lui seront fourni. Votre mission doit ressembler \u00e0 cela : . \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 entry.rs \u251c\u2500\u2500 runner \u251c\u2500\u2500 solution.js \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 Main.rs \u2514\u2500\u2500 template \u251c\u2500\u2500 c \u2502 \u2514\u2500\u2500 Main.c \u251c\u2500\u2500 cpp \u2502 \u2514\u2500\u2500 Main.cpp \u251c\u2500\u2500 go \u2502 \u2514\u2500\u2500 Main.go \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 Main.java \u251c\u2500\u2500 javascript \u2502 \u2514\u2500\u2500 Main.js \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 Main.py \u251c\u2500\u2500 ruby \u2502 \u2514\u2500\u2500 Main.rb \u2514\u2500\u2500 rust \u2514\u2500\u2500 Main.rs","title":"Multi-langage"},{"location":"challenge-types/metamorph/#multi-langage-metamorph","text":"Vous pouvez cr\u00e9er une mission ind\u00e9pendamment du langage dans lequel elle sera r\u00e9solue. Le candidat est donc libre de choisir son langage pr\u00e9f\u00e9r\u00e9 pour r\u00e9soudre le probl\u00e8me ! Liste des langages support\u00e9s par Deadlock : Java 11.0.5 (openjdk) Kotlin 1.3.70-eap-184 Python 3.8.2 C/C++ 9.2.0 Rust 1.39.0 Go 1.12.16 Javascript avec NodeJS 12.15.0 Ruby 2.6.6 Ocaml 4.08.1 Imaginons que vous souhaitez \u00e9crire une mission d'impl\u00e9mentation de la suite de Fibonacci. Cr\u00e9er un nouveau dossier contenant un fichier entry.rs . Ce fichier d\u00e9finit : quel(s) langage(s) sont disponibles pour l'impl\u00e9mentation de la r\u00e9solution du candidat, tous les tests pour valider le code du candidat. 1 2 3 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ] }} Dans le premier tableau sont \u00e9num\u00e9r\u00e9 tous les langages que le candidat pourra s\u00e9lectionner au moment de d\u00e9velopper la solution \u00e0 la mission. Ensuite, vous devez \u00e9crire diff\u00e9rents tests, chacun sera ex\u00e9cut\u00e9 seulement si le pr\u00e9c\u00e9dent r\u00e9ussi. Ecrivons ensemble le premier ! 1 2 3 4 5 6 7 8 9 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 } ] }} Ce test va appeler le programme du candidat avec 0 comme entr\u00e9e et s'attend \u00e0 avoir 1 comme sortie . Par d\u00e9faut, pour chaque langage, le candidat dispose d'un template. Vous pouvez personnaliser le template pour chaque langage : Java Javascript Python Go C Cpp Ocaml Rust Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { if ( args . length > 0 ) { // Called when you submit your code. System . out . println ( fibonacci ( Long . ValueOf ( args [ 0 ] ))); } else { // Called when you run your code. System . out . println ( \"Hello World!\" ); } } public static long fibonacci ( long n ) { return n ; } } 1 2 3 4 5 6 7 8 9 10 11 12 // CommonJS if ( process . argv . length > 2 ) { // args given, code submitted console . log ( fibonacci ( process . argv [ 2 ])); } else { // no given, code ran console . log ( \"Hello World!\" ); } function fibonacci ( n ) { return n ; } 1 2 3 4 5 6 7 8 9 10 11 import sys ; def fibonacci ( n ): return n if ( len ( sys . argv ) > 1 ): # args given, code submitted print ( fibonacci ( sys . argv [ 1 ])) else : # no given, code ran print ( \"Hello World!\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \"fmt\" \"os\" ) func Fibonacci ( n int64 ) int64 { return n } func main () { if ( len ( os . Args ) > 1 ) { // args given, code submitted arg := os . Args [ 1 ] fmt . Println ( Fibonacci ( arg )) } else { // no given, code ran fmt . Println ( \"Hello World!\" ) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <stdlib.h> long fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( argv [ 1 ])); } else { // no given, code ran printf ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <bits/stdc++.h> bool fibonacci ( long n ) { return n ; } int main ( int argc , char ** argv ) { if ( argc > 1 ) { // args given, code submitted printf ( fibonacci ( stol ( argv [ 1 ]))) } else { // no given, code ran printf ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 let fibonacci n = let rec fib_2termes n a b = match n with | 0 -> a | 1 -> b | _ -> fib_2termes ( n - 1 ) b ( a + b ) in fib_2termes n 0 1 ;; if Array . length Sys . argv > 1 = true then print_int ( fibonacci ( int_of_string Sys . argv .( 1 )));; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); if args . len () == 2 { // Called when you submit your code. println! ( \"{}\" , fibonacci ( & args [ 1 ])) } else { // Called when you run your code. println! ( \"Hello World!\" ) } } fn fibonacci ( n : i64 ) -> i64 { n } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main def initialize if ( ARGV . length () > 0 ) then puts fibonacci ( ARGV [ 0 ]. to_i ) # args given, code submitted else puts \"Hello World!\" # no args given, code runner end end def fibonacci ( n ) 0 end end # initialize object Main . new L'utilisateur doit compl\u00e9ter la m\u00e9thode fibonacci et le r\u00e9sultat sera affich\u00e9 dans le stdout (console). Continuons avec plus de tests : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 challenge ! {{ \"languages\" : [ \"java\" , \"python\" , \"c\" , \"cpp\" , \"go\" , \"ruby\" , \"rust\" , \"javascript\" ], \"tests\" : [ { input : 0 , expected : 1 }, { input : 1 , expected : 1 }, { input : 2 , expected : 2 }, { input : 3 , expected : 3 }, { input : 10 , expected : 89 } ] }}","title":"Multi-langage (metamorph)"},{"location":"challenge-types/metamorph/#tests-aleatoires","text":"Cela vous semble trop statique ? Vous pouvez ajouter des tests plus complexe avec des entr\u00e9es al\u00e9atoires en utilisant la m\u00e9thode random fournie par notre runner : randt(n) : g\u00e9n\u00e8re un nombre al\u00e9atoire entre 0 et n exclu. randft(n, m) : gn\u00e8re un nombre al\u00e9atoire entre n et m exclu. 1 2 3 4 { input : randft ( 20 , 30 ), expected : ? } Cela pose un probl\u00e8me. Que devons nous \u00e9crire dans la valeur attendue ? Pas de panique, vous pouvez appeler votre propre solution au lieu d'\u00e9crire une r\u00e9ponse attendue statique ! 1 2 3 4 5 6 7 8 { input : randft ( 20 , 30 ), expected : call ( \"java\" , \"Solution.java\" ) }, { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ) } La m\u00eame logique est appliqu\u00e9e, votre solution.py est appel\u00e9e par notre interpr\u00e8teur Python avec les donn\u00e9es de input et vous devez \u00e9crire le r\u00e9sultat renvoy\u00e9 par votre solution dans le stdout . Par exemple pour la suite de Fibonnaci : 1 2 3 4 5 6 7 8 # solution.py def fibo ( n ): if n <= 1 : return n else : return ( fibo ( n - 1 ) + fibo ( n - 2 )) print ( fibo ( sys . argv [ 1 ])) Ensuite la sortie stdout donn\u00e9e avec la m\u00e9thode print est compar\u00e9e \u00e0 celle r\u00e9sultant du programme du candidat. Vous pouvez choisir un interpr\u00e8teur parmi la liste de ceux propos\u00e9 ci-apr\u00e8s : java javascript ruby c rust python go cpp","title":"Tests al\u00e9atoires"},{"location":"challenge-types/metamorph/#repetition","text":"Qu'en est-il si vous d\u00e9sirez ex\u00e9cuter 50 tests al\u00e9atoire \u00e0 la suite ? Ce n'est pas un probl\u00e8me, tout ce que vous avez \u00e0 faire est d'ajouter le param\u00e8tre repeat \u00e0 votre test : { input : randt ( 20 ), expected : call ( \"python\" , \"solution.py\" ), repeat : 50 }","title":"R\u00e9p\u00e9tition"},{"location":"challenge-types/metamorph/#valeur-dentree","text":"Ce n'est pas tout, vous pouvez aussi appeler votre propre programme pour g\u00e9n\u00e9rer les valeurs d'entr\u00e9e : { input : call ( \"javascript\" , \"generate.js\" ), expected : call ( \"python\" , \"solution.py\" ) }","title":"Valeur d'entr\u00e9e"},{"location":"challenge-types/metamorph/#ouvrir-un-ficher","text":"Vous pouvez \u00e9galement ouvrir un fichier : { input : open ( \"file.txt\" ), expected : call ( \"python\" , \"solution.py\" ) } Il sera servi au candidat en tant que Cha\u00eene de caract\u00e8re . D\u00e8s que vous aurez compl\u00e9ter le fichier entry.rs , il faut compl\u00e9ter le fichier challenge.yaml : version : 1.0 name : code_metamorph_fibo label : Fibonacci description : Implements Fibonacci algorithm level : ewok type : CODING metamorph : true xp : programming : 1 coding : templateDirectory : /opt/runner successDirectory : success/ target : main.rs editorMode : rust Le dossier success/ contient votre solution qui sera donn\u00e9e au candidat lorsqu'il aura r\u00e9solu le probl\u00e8me de la mission. Vous \u00eates libre de choisir le langage et la logique d'impl\u00e9mentation de votre solution. Pour tester votre programme, vous pouvez utiliser notre CLI : > dcli run . java # Ex\u00e9cute template/java/Main.java > dcli solve . java # Ex\u00e9cute les tests sur template/java/Main.java > dcli run . python # Ex\u00e9cute template/python/Main.py Chaque fichier placer dans le dossier template est donn\u00e9 au candidat lorsqu'il d\u00e9cide de changer le langage selectionn\u00e9. Par exemple, si le candidat d\u00e9cide d'utiliser l'interpr\u00e9teur Rust , tous les fichier contenu dans template/rust lui seront fourni. Votre mission doit ressembler \u00e0 cela : . \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 entry.rs \u251c\u2500\u2500 runner \u251c\u2500\u2500 solution.js \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 Main.rs \u2514\u2500\u2500 template \u251c\u2500\u2500 c \u2502 \u2514\u2500\u2500 Main.c \u251c\u2500\u2500 cpp \u2502 \u2514\u2500\u2500 Main.cpp \u251c\u2500\u2500 go \u2502 \u2514\u2500\u2500 Main.go \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 Main.java \u251c\u2500\u2500 javascript \u2502 \u2514\u2500\u2500 Main.js \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 Main.py \u251c\u2500\u2500 ruby \u2502 \u2514\u2500\u2500 Main.rb \u2514\u2500\u2500 rust \u2514\u2500\u2500 Main.rs","title":"Ouvrir un ficher"},{"location":"challenge-types/multi-service/","text":"Missions multi-service Parfois, vous devrez d\u00e9clarer plusieurs services dans votre mission. Cette fonctionnalit\u00e9 est totalement supporter et utilise les r\u00e9seaux de conteneurs (container network). Nous allons vous guider dans le processus d'ajout d'un service suppl\u00e9mentaire appel\u00e9 db . Dans le dossier principal de votre mission, cr\u00e9er les dossiers code_your_mission/services/db . Ce dossier va contenir les fichiers de votre service. Dans ce dossier, vous devez cr\u00e9er au moins ces deux fichiers : Le descripteur du service service.yaml Le conteneur du service Dockerfile Le descripteur du service Le descripteur du service expose les ports et un alias sp\u00e9cifique (qui doit \u00eatre le nom du service). En suivant cet exemple, le service db ressemblerait \u00e0 : name : db exposed_ports : - 5432 Un exemple de mission multi-services est disponible ici .","title":"Multi-service"},{"location":"challenge-types/multi-service/#missions-multi-service","text":"Parfois, vous devrez d\u00e9clarer plusieurs services dans votre mission. Cette fonctionnalit\u00e9 est totalement supporter et utilise les r\u00e9seaux de conteneurs (container network). Nous allons vous guider dans le processus d'ajout d'un service suppl\u00e9mentaire appel\u00e9 db . Dans le dossier principal de votre mission, cr\u00e9er les dossiers code_your_mission/services/db . Ce dossier va contenir les fichiers de votre service. Dans ce dossier, vous devez cr\u00e9er au moins ces deux fichiers : Le descripteur du service service.yaml Le conteneur du service Dockerfile","title":"Missions multi-service"},{"location":"challenge-types/multi-service/#le-descripteur-du-service","text":"Le descripteur du service expose les ports et un alias sp\u00e9cifique (qui doit \u00eatre le nom du service). En suivant cet exemple, le service db ressemblerait \u00e0 : name : db exposed_ports : - 5432 Un exemple de mission multi-services est disponible ici .","title":"Le descripteur du service"},{"location":"challenge-types/score/","text":"Mission Score Lorsque vous cr\u00e9ez une mission de code, le candidat dispose de deux mani\u00e8res d'ex\u00e9cuter son code (Plus d'infos ici ) : Ex\u00e9cuter -> ex\u00e9cute le code seul sans les tests Soumettre -> ex\u00e9cute le code avec les tests que vous avez fournis. Il est possible de retourner un score lorsque vous testez le code du candidat. Par exemple, si vous consid\u00e9rez que si 50 tests valid\u00e9s sur les 100 disponibles suffisent \u00e0 consid\u00e9rer la mission comme r\u00e9ussie, vous devez l'\u00e9crire de cette mani\u00e8re (d\u00e9pendante du langage) : Java Python public static void main ( String [] args ) { // test user code Mission . INSTANCE . done ( 50 ); } def main (): # test user code Mission . done ( 50 ): Vous pouvez \u00e9galement sp\u00e9cifier d'autre champs dans le challenge.yml : score : min : 0 # score minimum par d\u00e9faut (optionnel) minToValidate : 90 # score minimum pour valider la mission max : 100 # score maximum par d\u00e9faut (optionnel) Le candidat dispose alors d'un nouvel onglet sur son interface juste \u00e0 cot\u00e9 de la Console . Exemple code_score_python","title":"Score"},{"location":"challenge-types/score/#mission-score","text":"Lorsque vous cr\u00e9ez une mission de code, le candidat dispose de deux mani\u00e8res d'ex\u00e9cuter son code (Plus d'infos ici ) : Ex\u00e9cuter -> ex\u00e9cute le code seul sans les tests Soumettre -> ex\u00e9cute le code avec les tests que vous avez fournis. Il est possible de retourner un score lorsque vous testez le code du candidat. Par exemple, si vous consid\u00e9rez que si 50 tests valid\u00e9s sur les 100 disponibles suffisent \u00e0 consid\u00e9rer la mission comme r\u00e9ussie, vous devez l'\u00e9crire de cette mani\u00e8re (d\u00e9pendante du langage) : Java Python public static void main ( String [] args ) { // test user code Mission . INSTANCE . done ( 50 ); } def main (): # test user code Mission . done ( 50 ): Vous pouvez \u00e9galement sp\u00e9cifier d'autre champs dans le challenge.yml : score : min : 0 # score minimum par d\u00e9faut (optionnel) minToValidate : 90 # score minimum pour valider la mission max : 100 # score maximum par d\u00e9faut (optionnel) Le candidat dispose alors d'un nouvel onglet sur son interface juste \u00e0 cot\u00e9 de la Console .","title":"Mission Score"},{"location":"challenge-types/score/#exemple","text":"code_score_python","title":"Exemple"},{"location":"challenge-types/sql/","text":"Missions SQL Une mission SQL est une mission classique de code avec une base de donn\u00e9e distante inject\u00e9e via un service. Plus d'infos sur les services Le conteneur principal se connecte au service, ex\u00e9cute les requ\u00eates du candidat puis v\u00e9rifie que tout s'est bien d\u00e9roul\u00e9. Il y a deux types principaux de missions SQL : Missions en lecture seule Par exemple, la r\u00e9ponse \u00e0 votre mission pourrait ressembler \u00e0 SELECT * FROM public.\"myTable\" ... Dans ce cas vous avez besoin de : Ex\u00e9cuter la r\u00e9ponse attendue et stocker le r\u00e9sultat dans first ! Ex\u00e9cuter la r\u00e9ponse du candidat et stocker le r\u00e9sultat dans only after ! Comparer les deux r\u00e9ponses Il est n\u00e9cessaire d'ex\u00e9cuter votre r\u00e9ponse en premier afin d'\u00e9viter tout retour en arri\u00e8re de la base de donn\u00e9e que le code du candidat pourrait provoquer. Missions d'\u00e9dition Ce type de mission est un peu plus compliqu\u00e9 \u00e0 valider. Elles d\u00e9butent g\u00e9n\u00e9ralement par : DELETE/UPDATE/ALTER TABLE ... Dans ce cas, Il est n\u00e9cessaire d'\u00e9crire un fichier checker.sql (g\u00e9n\u00e9ralement avec une requ\u00eate SELECT ) en plus du fichier success/query.sql . Le fichier success/query.sql modifie la base de donn\u00e9es (c'est la r\u00e9ponse attendue) et le fichier checker.sql s\u00e9lectionne toutes les lignes qui nous int\u00e9ressent dans la base de donn\u00e9es Ex\u00e9cuter la r\u00e9ponse attendue Ex\u00e9cuter le script checker.sql et stocker le r\u00e9sultat Faire un retour-arri\u00e8re sur la base de donn\u00e9es Ex\u00e9cuter la r\u00e9ponse donn\u00e9e par le candidat Ex\u00e9cuter le script checker.sql et stocker le r\u00e9sultat Comparer les deux r\u00e9ponses Exemple d'arborescence d'une mission SQL \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png Exemple https://github.com/deadlock-resources/challenge-examples/tree/master/example/code_sql","title":"SQL"},{"location":"challenge-types/sql/#missions-sql","text":"Une mission SQL est une mission classique de code avec une base de donn\u00e9e distante inject\u00e9e via un service. Plus d'infos sur les services Le conteneur principal se connecte au service, ex\u00e9cute les requ\u00eates du candidat puis v\u00e9rifie que tout s'est bien d\u00e9roul\u00e9. Il y a deux types principaux de missions SQL :","title":"Missions SQL"},{"location":"challenge-types/sql/#missions-en-lecture-seule","text":"Par exemple, la r\u00e9ponse \u00e0 votre mission pourrait ressembler \u00e0 SELECT * FROM public.\"myTable\" ... Dans ce cas vous avez besoin de : Ex\u00e9cuter la r\u00e9ponse attendue et stocker le r\u00e9sultat dans first ! Ex\u00e9cuter la r\u00e9ponse du candidat et stocker le r\u00e9sultat dans only after ! Comparer les deux r\u00e9ponses Il est n\u00e9cessaire d'ex\u00e9cuter votre r\u00e9ponse en premier afin d'\u00e9viter tout retour en arri\u00e8re de la base de donn\u00e9e que le code du candidat pourrait provoquer.","title":"Missions en lecture seule"},{"location":"challenge-types/sql/#missions-dedition","text":"Ce type de mission est un peu plus compliqu\u00e9 \u00e0 valider. Elles d\u00e9butent g\u00e9n\u00e9ralement par : DELETE/UPDATE/ALTER TABLE ... Dans ce cas, Il est n\u00e9cessaire d'\u00e9crire un fichier checker.sql (g\u00e9n\u00e9ralement avec une requ\u00eate SELECT ) en plus du fichier success/query.sql . Le fichier success/query.sql modifie la base de donn\u00e9es (c'est la r\u00e9ponse attendue) et le fichier checker.sql s\u00e9lectionne toutes les lignes qui nous int\u00e9ressent dans la base de donn\u00e9es Ex\u00e9cuter la r\u00e9ponse attendue Ex\u00e9cuter le script checker.sql et stocker le r\u00e9sultat Faire un retour-arri\u00e8re sur la base de donn\u00e9es Ex\u00e9cuter la r\u00e9ponse donn\u00e9e par le candidat Ex\u00e9cuter le script checker.sql et stocker le r\u00e9sultat Comparer les deux r\u00e9ponses","title":"Missions d'\u00e9dition"},{"location":"challenge-types/sql/#exemple-darborescence-dune-mission-sql","text":"\u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png","title":"Exemple d'arborescence d'une mission SQL"},{"location":"challenge-types/sql/#exemple","text":"https://github.com/deadlock-resources/challenge-examples/tree/master/example/code_sql","title":"Exemple"},{"location":"challenge-types/vscode/","text":"Challenge VsCode Les autres types de challenge ne vous conviennent pas ? Vous vous sentez \u00e0 l'\u00e9troit ? Vous voulez que vos \u00e9tudiants puisse profiter d'un \u00e9diteur complet ? Il est temps d'utiliser VsCode dans le navigateur ! Mais avant toute chose, vous devez \u00eatre familier avec le DCLI et les bases de cr\u00e9ation de missions Comment ? Il vous suffit de cr\u00e9er les fichiers suivants : \u251c\u2500\u2500 base \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u251c\u2500\u2500 main \u2502 \u2502 \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 io \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 deadlock \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 CdbApplication.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources / \u2502 \u2502 \u2514\u2500\u2500 test / \u2502 \u2514\u2500\u2500 webapp / \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 briefing.md \u2514\u2500\u2500 thumbnail.png base dossier contenant les fichiers utilisateurs, ces fichiers seront fournis au candidat lorsque l'IDE d\u00e9marre. docs contient le briefing, les instructions utilisateurs. Le briefing sera ouvert au d\u00e9marrage de l'IDE. Dockerfile FROM registry.e-biz.fr/deadlock-public/deadlock-theia:latest # Vous pouvez installer tout ce que vous voulez # Le gestionnaire de package est *apt* # les path de destination paths ne doivent pas \u00eatre modifi\u00e9s COPY base /project # copie le repertoire user dans /project COPY docs /home/theia/docs # copie les instructions challenge.yaml est le fichier descripteur version : 0.1 name : code_persist_crud label : Crud description : This is your moment, you have to create your own CRUD. Your customer requested you to build a Computer DataBase application (codename *CDB*). level : ewok # difficult\u00e9 du challenge [comment \u00e7a marche](https://deadlock-resources.github.io/challenge-documentation/#level) type : PERSISTENT # obligatoire xp : # points d'exp\u00e9rience, vous pouvez ajouter les labels que vous voulez programming : 1 # c'est un poids, pas un nombre java : 1 coding : userDirectory : base resources : # Ressources allou\u00e9es au conteneur, ne pas modifier si vous n'\u00eates pas confiant sur le sujet cpuLimit : \"1200m\" memoryLimit : \"1200Mi\" cpuRequest : \"1000m\" memoryRequest : \"1000Mi\" persistent : ports : # ports que vous souhaitez laisser ouvert pour le candidat web : 3000 # obligatoire crud : 9090 # la personne se verra attribuer une url qui redirigera vers le port 9090 thumbnail.png image du challenge Ajouter des images au briefing ![toast](image:toast.jpg) ![Something Else](image:dir/else.png) Vous devez pr\u00e9fixer le path de votre image avec image: Comment tester ? > cd ./code_persist_crud > dcli run . Cela vou donnera un lien cliquable que vous pourrez copier dans votre navigateur pr\u00e9f\u00e9r\u00e9. Ajout de services au d\u00e9marrage Imaginons que vous ayez besoin d'un service au d\u00e9marrage d'une mission. Par exemple une base de donn\u00e9es Postgres Il vous suffit d'ajouter un script startup.sh dans votre image Docker : COPY startup.sh /deadlock/startup.sh et par exemple \u00e0 l'int\u00e9rieur de ce startup.sh : #!/bin/sh # Launch postgres service on startup service postgresql start Le script startup.sh s'ex\u00e9cute lorsque le conteneur Docker d\u00e9marre. Si vous avez besoin de remplir la base de donn\u00e9es, il est pr\u00e9f\u00e9rable de le faire dans le Dockerfile (utiliser un script au d\u00e9marrage va allonger le d\u00e9marrage du container) : # installation de Postgresql RUN apt-get -y update RUN apt-get -y install postgresql USER postgres COPY db/sql /sql # remplissage de la base de donn\u00e9es RUN /etc/init.d/postgresql start && \\ psql --command \"CREATE USER deadlock WITH SUPERUSER PASSWORD 'no-passwd';\" && \\ createdb -O deadlock deadlock-db && \\ psql -d deadlock-db -U deadlock -f /sql/1__schema.sql -f /sql/2__entries.sql && \\","title":"VsCode"},{"location":"challenge-types/vscode/#challenge-vscode","text":"Les autres types de challenge ne vous conviennent pas ? Vous vous sentez \u00e0 l'\u00e9troit ? Vous voulez que vos \u00e9tudiants puisse profiter d'un \u00e9diteur complet ? Il est temps d'utiliser VsCode dans le navigateur ! Mais avant toute chose, vous devez \u00eatre familier avec le DCLI et les bases de cr\u00e9ation de missions","title":"Challenge VsCode"},{"location":"challenge-types/vscode/#comment","text":"Il vous suffit de cr\u00e9er les fichiers suivants : \u251c\u2500\u2500 base \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u251c\u2500\u2500 main \u2502 \u2502 \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 io \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 deadlock \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 CdbApplication.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 resources / \u2502 \u2502 \u2514\u2500\u2500 test / \u2502 \u2514\u2500\u2500 webapp / \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 briefing.md \u2514\u2500\u2500 thumbnail.png base dossier contenant les fichiers utilisateurs, ces fichiers seront fournis au candidat lorsque l'IDE d\u00e9marre. docs contient le briefing, les instructions utilisateurs. Le briefing sera ouvert au d\u00e9marrage de l'IDE. Dockerfile FROM registry.e-biz.fr/deadlock-public/deadlock-theia:latest # Vous pouvez installer tout ce que vous voulez # Le gestionnaire de package est *apt* # les path de destination paths ne doivent pas \u00eatre modifi\u00e9s COPY base /project # copie le repertoire user dans /project COPY docs /home/theia/docs # copie les instructions challenge.yaml est le fichier descripteur version : 0.1 name : code_persist_crud label : Crud description : This is your moment, you have to create your own CRUD. Your customer requested you to build a Computer DataBase application (codename *CDB*). level : ewok # difficult\u00e9 du challenge [comment \u00e7a marche](https://deadlock-resources.github.io/challenge-documentation/#level) type : PERSISTENT # obligatoire xp : # points d'exp\u00e9rience, vous pouvez ajouter les labels que vous voulez programming : 1 # c'est un poids, pas un nombre java : 1 coding : userDirectory : base resources : # Ressources allou\u00e9es au conteneur, ne pas modifier si vous n'\u00eates pas confiant sur le sujet cpuLimit : \"1200m\" memoryLimit : \"1200Mi\" cpuRequest : \"1000m\" memoryRequest : \"1000Mi\" persistent : ports : # ports que vous souhaitez laisser ouvert pour le candidat web : 3000 # obligatoire crud : 9090 # la personne se verra attribuer une url qui redirigera vers le port 9090 thumbnail.png image du challenge","title":"Comment ?"},{"location":"challenge-types/vscode/#ajouter-des-images-au-briefing","text":"![toast](image:toast.jpg) ![Something Else](image:dir/else.png) Vous devez pr\u00e9fixer le path de votre image avec image:","title":"Ajouter des images au briefing"},{"location":"challenge-types/vscode/#comment-tester","text":"> cd ./code_persist_crud > dcli run . Cela vou donnera un lien cliquable que vous pourrez copier dans votre navigateur pr\u00e9f\u00e9r\u00e9.","title":"Comment tester ?"},{"location":"challenge-types/vscode/#ajout-de-services-au-demarrage","text":"Imaginons que vous ayez besoin d'un service au d\u00e9marrage d'une mission. Par exemple une base de donn\u00e9es Postgres Il vous suffit d'ajouter un script startup.sh dans votre image Docker : COPY startup.sh /deadlock/startup.sh et par exemple \u00e0 l'int\u00e9rieur de ce startup.sh : #!/bin/sh # Launch postgres service on startup service postgresql start Le script startup.sh s'ex\u00e9cute lorsque le conteneur Docker d\u00e9marre. Si vous avez besoin de remplir la base de donn\u00e9es, il est pr\u00e9f\u00e9rable de le faire dans le Dockerfile (utiliser un script au d\u00e9marrage va allonger le d\u00e9marrage du container) : # installation de Postgresql RUN apt-get -y update RUN apt-get -y install postgresql USER postgres COPY db/sql /sql # remplissage de la base de donn\u00e9es RUN /etc/init.d/postgresql start && \\ psql --command \"CREATE USER deadlock WITH SUPERUSER PASSWORD 'no-passwd';\" && \\ createdb -O deadlock deadlock-db && \\ psql -d deadlock-db -U deadlock -f /sql/1__schema.sql -f /sql/2__entries.sql && \\","title":"Ajout de services au d\u00e9marrage"},{"location":"mode/","text":"Bac \u00e0 sable (Sandbox) Il existe un autre mode pour les missions, le mode bac \u00e0 sable (sandbox). Les missions classiques doivent contenir plusieurs tests permettant de verifier que le candidat a bien r\u00e9ussi la mission. Mais parfois, il est difficile voire impossible d'impl\u00e9menter suffisamment de test pour s'assurer que le candidat ait bien compris et r\u00e9ussi le challenge. Vous pouvez alors cr\u00e9er une mission sans aucun test, mais vous devrez tout de m\u00eame cr\u00e9er la classe Run. Le professeur pourra valider la mission via la page de l'\u00e9tudiant. Il vous suffit d'ajouter la ligne sandboxed: true dans le fichier challenge.yml. Exemple : name : code_interview_card_game label : Card Game description : Card Game level : ewok type : CODING sandboxed : true Liste noire Par d\u00e9faut, il existe une liste noire de mots que le candidat ne peut pas ins\u00e9rer dans son code. Un exemple est disponible dans le r\u00e9pertoire contenant toutes les missions de Deadlock. Vous trouverez au m\u00eame niveau que les missions, un dossier resources contenant les ressources utile pour la cr\u00e9ation d'une mission dont un exemple de liste noire dans default/blacklist . Vous pouvez \u00e9galement cr\u00e9er votre propre liste noire pour une mission en cr\u00e9ant un fichier blacklist au m\u00eame niveau que le challenge.yml et en le remplissant comme un fichier csv. Il supporte \u00e9galement les expressions r\u00e9guli\u00e8re (regex). Exemple de fichier blacklist : [ ^<> ]( < | > )[ ^>< ] , ( System \\. exit \\( )( \\d ) * ( \\) ) , ( Runtime \\. getRuntime \\(\\)\\. exit \\(\\d * \\) )","title":"Mode"},{"location":"mode/#bac-a-sable-sandbox","text":"Il existe un autre mode pour les missions, le mode bac \u00e0 sable (sandbox). Les missions classiques doivent contenir plusieurs tests permettant de verifier que le candidat a bien r\u00e9ussi la mission. Mais parfois, il est difficile voire impossible d'impl\u00e9menter suffisamment de test pour s'assurer que le candidat ait bien compris et r\u00e9ussi le challenge. Vous pouvez alors cr\u00e9er une mission sans aucun test, mais vous devrez tout de m\u00eame cr\u00e9er la classe Run. Le professeur pourra valider la mission via la page de l'\u00e9tudiant. Il vous suffit d'ajouter la ligne sandboxed: true dans le fichier challenge.yml. Exemple : name : code_interview_card_game label : Card Game description : Card Game level : ewok type : CODING sandboxed : true","title":"Bac \u00e0 sable (Sandbox)"},{"location":"mode/#liste-noire","text":"Par d\u00e9faut, il existe une liste noire de mots que le candidat ne peut pas ins\u00e9rer dans son code. Un exemple est disponible dans le r\u00e9pertoire contenant toutes les missions de Deadlock. Vous trouverez au m\u00eame niveau que les missions, un dossier resources contenant les ressources utile pour la cr\u00e9ation d'une mission dont un exemple de liste noire dans default/blacklist . Vous pouvez \u00e9galement cr\u00e9er votre propre liste noire pour une mission en cr\u00e9ant un fichier blacklist au m\u00eame niveau que le challenge.yml et en le remplissant comme un fichier csv. Il supporte \u00e9galement les expressions r\u00e9guli\u00e8re (regex). Exemple de fichier blacklist : [ ^<> ]( < | > )[ ^>< ] , ( System \\. exit \\( )( \\d ) * ( \\) ) , ( Runtime \\. getRuntime \\(\\)\\. exit \\(\\d * \\) )","title":"Liste noire"}]}